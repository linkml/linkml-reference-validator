{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"linkml-reference-validator","text":"<p>Validate quotes and excerpts against their source publications</p> <p>linkml-reference-validator ensures that text excerpts in your data accurately match their cited sources. It fetches references from PubMed/PMC, DOIs, local files, and URLs, then performs deterministic substring matching with support for editorial conventions like brackets <code>[...]</code> and ellipsis <code>...</code>.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Deterministic validation - No fuzzy matching or AI hallucinations</li> <li>Multiple reference sources - PubMed, DOIs, local files, and URLs</li> <li>Editorial convention support - Handles <code>[clarifications]</code> and <code>...</code> ellipsis</li> <li>Title validation - Verify reference titles with <code>dcterms:title</code></li> <li>Multiple interfaces - CLI for quick checks, Python API for integration</li> <li>LinkML integration - Validates data files with <code>linkml:excerpt</code> annotations</li> <li>Smart caching - Stores references locally to avoid repeated API calls</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Quickstart - Get started in 5 minutes</li> <li>CLI Reference - Complete command documentation</li> <li>How It Works - Understanding the validation process</li> <li>Editorial Conventions - Using brackets and ellipsis</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>Getting Started (CLI) - Validate quotes from the command line</li> <li>Advanced Usage (CLI) - Batch processing with LinkML schemas</li> <li>Python API - Programmatic usage for custom applications</li> </ul>"},{"location":"about/","title":"About linkml-reference-validator","text":"<p>Validation of supporting text from references and publications</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Get started with linkml-reference-validator in 5 minutes.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<pre><code>pip install linkml-reference-validator\n</code></pre> <p>Or with uv:</p> <pre><code>uv pip install linkml-reference-validator\n</code></pre>"},{"location":"quickstart/#validate-a-single-quote","title":"Validate a Single Quote","text":"<p>The most common use case - verify that a quote appears in its cited reference:</p> <pre><code>linkml-reference-validator validate text \\\n  \"MUC1 oncoprotein blocks nuclear targeting of c-Abl\" \\\n  PMID:16888623\n</code></pre> <p>Output:</p> <pre><code>Validating text against PMID:16888623...\n  Text: MUC1 oncoprotein blocks nuclear targeting of c-Abl\n\nResult:\n  Valid: True\n  Message: Supporting text validated successfully in PMID:16888623\n</code></pre> <p>The reference is automatically fetched from PubMed and cached locally in <code>references_cache/</code>.</p>"},{"location":"quickstart/#validate-data-files","title":"Validate Data Files","text":"<p>For batch validation, create a LinkML schema and data file:</p> <p>schema.yaml:</p> <pre><code>id: https://example.org/my-schema\nname: my-schema\n\nprefixes:\n  linkml: https://w3id.org/linkml/\n\nclasses:\n  Statement:\n    attributes:\n      id:\n        identifier: true\n      supporting_text:\n        slot_uri: linkml:excerpt\n      reference:\n        slot_uri: linkml:authoritative_reference\n</code></pre> <p>data.yaml:</p> <pre><code>- id: stmt1\n  supporting_text: MUC1 oncoprotein blocks nuclear targeting of c-Abl\n  reference: PMID:16888623\n</code></pre> <p>Validate:</p> <pre><code>linkml-reference-validator validate data \\\n  data.yaml \\\n  --schema schema.yaml \\\n  --target-class Statement\n</code></pre>"},{"location":"quickstart/#validate-against-a-doi","title":"Validate Against a DOI","text":"<p>You can also validate text against DOIs using the Crossref API:</p> <pre><code>linkml-reference-validator validate text \\\n  \"Nanometre-scale thermometry\" \\\n  DOI:10.1038/nature12373\n</code></pre> <p>This works the same way as PMID validation - the reference is fetched and cached locally.</p>"},{"location":"quickstart/#validate-against-local-files","title":"Validate Against Local Files","text":"<p>You can also validate against local markdown, text, or HTML files:</p> <pre><code>linkml-reference-validator validate text \\\n  \"JAK1 binds to the receptor complex\" \\\n  file:./research/jak-notes.md\n</code></pre>"},{"location":"quickstart/#validate-against-urls","title":"Validate Against URLs","text":"<p>Web pages can also be used as references:</p> <pre><code>linkml-reference-validator validate text \\\n  \"Climate change affects biodiversity\" \\\n  url:https://example.org/climate-report.html\n</code></pre>"},{"location":"quickstart/#key-features","title":"Key Features","text":"<ul> <li>Automatic Caching: References cached locally after first fetch</li> <li>Editorial Notes: Use <code>[...]</code> for clarifications: <code>\"MUC1 [mucin 1] oncoprotein\"</code></li> <li>Ellipsis: Use <code>...</code> for omitted text: <code>\"MUC1 ... nuclear targeting\"</code></li> <li>Title Validation: Verify reference titles with <code>dcterms:title</code></li> <li>Deterministic Matching: Substring-based (not AI/fuzzy matching)</li> <li>PubMed &amp; PMC: Fetches from NCBI automatically</li> <li>DOI Support: Fetches metadata from Crossref API</li> <li>Local Files: Validate against markdown, text, or HTML files</li> <li>URL Support: Validate against web pages</li> </ul>"},{"location":"quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Tutorial 1: Getting Started - CLI basics with real examples</li> <li>Tutorial 2: Advanced Usage - Data validation with LinkML schemas</li> <li>Validating Reference Titles - Verify titles with <code>dcterms:title</code></li> <li>Concepts - Understanding the validation process</li> <li>CLI Reference - Complete command documentation</li> </ul>"},{"location":"todo/","title":"Future Enhancements","text":"<p>This document tracks planned and potential enhancements for linkml-reference-validator.</p>"},{"location":"todo/#roadmap","title":"Roadmap","text":""},{"location":"todo/#full-text-access-improvements","title":"Full Text Access Improvements","text":""},{"location":"todo/#pdf-support","title":"PDF Support","text":"<p>Status: Planned</p> <p>Currently, local files must be text or markdown. PDF support would enable:</p> <ul> <li>Direct validation against local PDF files (<code>file:./paper.pdf</code>)</li> <li>Automatic text extraction from downloaded papers</li> <li>Integration with reference managers that store PDFs</li> </ul> <p>Potential libraries: - pymupdf4llm - Best balance of speed and quality - marker-pdf - Best structure preservation for complex layouts</p> <p>Challenges: - Scientific papers have complex layouts (multi-column, figures, tables) - OCR needed for scanned PDFs - Text extraction quality varies significantly</p>"},{"location":"todo/#zotero-integration","title":"Zotero Integration","text":"<p>Status: Under consideration</p> <p>Integration with Zotero would enable:</p> <ul> <li>Fetching full text from Zotero library attachments</li> <li>Using Zotero's cached PDFs for validation</li> <li>Syncing with Zotero collections</li> </ul> <p>Potential approach: - pyzotero - Official Python API wrapper - pyzotero-local - Direct SQLite database access - Zotero 7 local API (<code>http://localhost:23119/api/</code>)</p> <p>Note: Zotero 7 beta includes a <code>/fulltext</code> endpoint for retrieving full content.</p>"},{"location":"todo/#paperpile-integration","title":"Paperpile Integration","text":"<p>Status: Blocked (no API)</p> <p>Paperpile does not provide a public API. Integration would require:</p> <ul> <li>Manual BibTeX export + PDF file association</li> <li>Unofficial workarounds</li> </ul> <p>See Paperpile API feature request.</p>"},{"location":"todo/#validation-enhancements","title":"Validation Enhancements","text":""},{"location":"todo/#cross-source-fallback","title":"Cross-Source Fallback","text":"<p>Status: Under consideration</p> <p>When a PMID has no PMC full text, automatically try:</p> <ol> <li>DOI lookup via Crossref</li> <li>URL if available in metadata</li> <li>User-configured fallback sources</li> </ol>"},{"location":"todo/#content-type-preferences","title":"Content Type Preferences","text":"<p>Status: Under consideration</p> <p>Allow users to configure validation strictness based on content type:</p> <pre><code>validation:\n  require_full_text: true  # Fail if only abstract available\n  warn_on_abstract_only: true  # Warn but don't fail\n</code></pre>"},{"location":"todo/#common-issue-detection-from-ai-gene-review","title":"Common Issue Detection (from ai-gene-review)","text":"<p>The following features are available in ai-gene-review and could be ported:</p>"},{"location":"todo/#1-ellipsis-detection","title":"1. Ellipsis Detection","text":"<p>Detect when <code>...</code> causes validation issues and suggest using only the first part of the quote:</p> <pre><code>if \"...\" in supporting_text:\n    first_part = supporting_text.split(\"...\")[0].strip()\n    suggestions.append(f\"Remove '...' - use only first part: \\\"{first_part}\\\"\")\n</code></pre>"},{"location":"todo/#2-short-text-detection","title":"2. Short Text Detection","text":"<p>Warn when query text is too short (&lt;20 chars after removing brackets):</p> <pre><code>if len(non_bracket_text) &lt; MIN_SPAN_LENGTH:\n    suggestions.append(f\"Too short ({len(non_bracket_text)} chars) - extend with context from source\")\n</code></pre>"},{"location":"todo/#3-bracket-ratio-detection","title":"3. Bracket Ratio Detection","text":"<p>Warn when bracketed content exceeds the actual quoted content:</p> <pre><code>bracket_content = ''.join(re.findall(r'\\[.*?\\]', supporting_text))\nif len(bracket_content) &gt; len(non_bracket_text):\n    suggestions.append(\"More brackets than quotes - reduce editorial additions\")\n</code></pre>"},{"location":"todo/#4-all-bracketed-detection","title":"4. All-Bracketed Detection","text":"<p>Error when supporting_text is entirely in brackets (no actual quoted text):</p> <pre><code>if total_query_length == 0:\n    return (\n        False,\n        \"Supporting text contains no quotable text - all content is in [brackets]. \"\n        \"Supporting text must contain actual quoted text from the source.\"\n    )\n</code></pre>"},{"location":"todo/#5-smart-editorial-bracket-detection","title":"5. Smart Editorial Bracket Detection","text":"<p>The <code>is_editorial_bracket()</code> method distinguishes between editorial notes and scientific notation:</p> <ul> <li>Editorial brackets (removed): <code>[important]</code>, <code>[The protein]</code>, <code>[according to studies]</code></li> <li>Scientific notation (kept): <code>[+21]</code>, <code>[G14]</code>, <code>[Ca 2+]</code>, <code>[Mg2+]</code></li> </ul>"},{"location":"todo/#reference-code","title":"Reference Code","text":"<p>See the following files in ai-gene-review for implementation details:</p> <ul> <li><code>src/ai_gene_review/validation/supporting_text_validator.py</code>:</li> <li><code>SupportingTextSubstringValidator</code> class</li> <li><code>generate_suggested_fix()</code> method (full version with issue detection)</li> <li> <p><code>is_editorial_bracket()</code> method</p> </li> <li> <p><code>src/ai_gene_review/validation/fuzzy_text_utils.py</code>:</p> </li> <li><code>find_fuzzy_match_with_context()</code> for position-aware matching</li> </ul>"},{"location":"todo/#contributing","title":"Contributing","text":"<p>Want to help implement these features? See GitHub Issues for current work items.</p>"},{"location":"concepts/content-types/","title":"Content Types","text":"<p>When fetching references, the validator tracks what type of content was retrieved using the <code>content_type</code> field. This is important because validation reliability depends on having access to the right content - an excerpt from a paper's Methods section won't be found if only the abstract is available.</p>"},{"location":"concepts/content-types/#content-type-values","title":"Content Type Values","text":"Value Source(s) Description <code>full_text_xml</code> PMID (via PMC) Full text retrieved from PubMed Central as XML <code>full_text_html</code> PMID (via PMC) Full text retrieved from PubMed Central as HTML (fallback) <code>abstract_only</code> PMID, DOI Only the abstract was available <code>summary</code> GEO, BioProject, BioSample, ClinicalTrials Database summary/description field <code>local_file</code> file: Content read from local filesystem <code>url</code> url: Content fetched from web URL <code>unavailable</code> Any No content could be retrieved"},{"location":"concepts/content-types/#internal-values-not-typically-seen-by-users","title":"Internal Values (not typically seen by users)","text":"Value Meaning <code>no_pmc</code> PMID has no corresponding PMC ID <code>pmc_restricted</code> PMC entry exists but content is restricted <code>unknown</code> Default value (content type not determined)"},{"location":"concepts/content-types/#how-content-type-affects-validation","title":"How Content Type Affects Validation","text":""},{"location":"concepts/content-types/#full-text-available-full_text_xml-full_text_html","title":"Full Text Available (<code>full_text_xml</code>, <code>full_text_html</code>)","text":"<p>When full text is available, validation is most reliable. The content includes:</p> <ul> <li>Abstract</li> <li>Introduction</li> <li>Methods</li> <li>Results</li> <li>Discussion</li> <li>References</li> </ul> <p>Excerpts from any section can be validated.</p>"},{"location":"concepts/content-types/#abstract-only-abstract_only","title":"Abstract Only (<code>abstract_only</code>)","text":"<p>When only the abstract is available:</p> <ul> <li>Validation works for text from the abstract</li> <li>Validation will fail for excerpts from other sections</li> <li>Error messages note this limitation: <code>(note: only abstract available for PMID:nnn, full text may contain this excerpt)</code></li> </ul> <p>This is common for PMIDs without open-access PMC versions.</p>"},{"location":"concepts/content-types/#summary-summary","title":"Summary (<code>summary</code>)","text":"<p>For database records (GEO, BioProject, etc.), the \"summary\" or \"description\" field is used. This is typically a brief description, not a full publication.</p>"},{"location":"concepts/content-types/#unavailable-unavailable","title":"Unavailable (<code>unavailable</code>)","text":"<p>No content was retrieved. Validation will fail with a clear error message.</p>"},{"location":"concepts/content-types/#pmid-full-text-cascade","title":"PMID Full Text Cascade","text":"<p>For PMID references, the validator automatically attempts to get the best content available:</p> <pre><code>flowchart TD\n    A[Fetch PMID] --&gt; B[Get abstract via Entrez]\n    B --&gt; C{Has PMC ID?}\n    C --&gt;|No| D[Return abstract_only]\n    C --&gt;|Yes| E[Try PMC XML]\n    E --&gt;|Success| F[Return full_text_xml]\n    E --&gt;|Fail| G[Try PMC HTML]\n    G --&gt;|Success| H[Return full_text_html]\n    G --&gt;|Fail/Restricted| I{Has abstract?}\n    I --&gt;|Yes| D\n    I --&gt;|No| J[Return unavailable]\n</code></pre> <p>When full text is retrieved, it's concatenated with the abstract to provide maximum coverage.</p>"},{"location":"concepts/content-types/#checking-content-type","title":"Checking Content Type","text":""},{"location":"concepts/content-types/#in-cache-files","title":"In Cache Files","text":"<p>Cached references store content type in YAML frontmatter:</p> <pre><code>---\nreference_id: PMID:16888623\ntitle: Example Article\ncontent_type: abstract_only\n---\n</code></pre>"},{"location":"concepts/content-types/#via-cli","title":"Via CLI","text":"<pre><code>linkml-reference-validator cache lookup PMID:16888623 --content\n</code></pre> <p>Output includes:</p> <pre><code>content_type: abstract_only\n</code></pre>"},{"location":"concepts/content-types/#in-validation-results","title":"In Validation Results","text":"<p>When validation fails and only abstract was available, the error message includes context:</p> <pre><code>Text part not found as substring: 'excerpt from methods section'\n(note: only abstract available for PMID:16888623, full text may contain this excerpt)\n</code></pre>"},{"location":"concepts/content-types/#strategies-when-full-text-unavailable","title":"Strategies When Full Text Unavailable","text":"<p>If validation fails due to abstract-only content:</p> <ol> <li> <p>Check for PMC version: Search PubMed Central for the article - if available, use <code>PMC:</code> prefix instead of <code>PMID:</code></p> </li> <li> <p>Use local file: If you have the PDF/text, save as markdown and reference with <code>file:./path/to/paper.md</code></p> </li> <li> <p>Use URL: If the full text is freely available online, use <code>url:https://...</code></p> </li> <li> <p>Remove the excerpt: If the excerpt can't be verified, consider removing it from your data</p> </li> <li> <p>Accept the limitation: Document that certain excerpts couldn't be verified due to access limitations</p> </li> </ol> <p>See Using Local Files and URLs for detailed guidance on alternatives.</p>"},{"location":"concepts/content-types/#reference-metadata","title":"Reference Metadata","text":"<p>Beyond the main content, the validator extracts additional metadata from references:</p>"},{"location":"concepts/content-types/#keywords","title":"Keywords","text":"<p>The <code>keywords</code> field contains subject terms or tags from the source:</p> Source Keyword Type Example PMID MeSH terms <code>Adaptor Proteins, Signal Transducing/metabolism</code> DOI (Crossref) Subjects <code>General Chemistry</code>, <code>Biochemistry</code> DOI (DataCite) Subjects <code>Climate Change</code>, <code>Bioinformatics</code> <p>MeSH (Medical Subject Headings) terms from PubMed are particularly valuable for biomedical literature, providing standardized vocabulary with qualifier subheadings (e.g., <code>/metabolism</code>, <code>/genetics</code>).</p> <p>Example cache file with keywords:</p> <pre><code>---\nreference_id: PMID:33505029\ntitle: Genomic mechanisms of climate adaptation...\nkeywords:\n- Acclimatization/genetics\n- Biofuels\n- Genetic Introgression\n- Genome, Plant/genetics\ncontent_type: abstract_only\n---\n</code></pre> <p>Viewing keywords via CLI:</p> <pre><code>linkml-reference-validator lookup PMID:33505029 --format text\n</code></pre> <p>Output:</p> <pre><code>Reference: PMID:33505029\nTitle: Genomic mechanisms of climate adaptation...\nKeywords: Acclimatization/genetics, Biofuels, Genetic Introgression, ...\n</code></pre>"},{"location":"concepts/content-types/#supplementary-files","title":"Supplementary Files","text":"<p>For repository DOIs (Zenodo, etc.), the <code>supplementary_files</code> field lists associated files:</p> <pre><code>---\nreference_id: DOI:10.5281/zenodo.7961621\nsupplementary_files:\n  - filename: data_analysis.xlsx\n    download_url: https://zenodo.org/api/records/7961621/files/data_analysis.xlsx/content\n    size_bytes: 123456\n    checksum: md5:88c66d378d886fea4969949c5877802f\n---\n</code></pre> <p>See Validating DOIs for details on supplementary files.</p>"},{"location":"concepts/editorial-conventions/","title":"Editorial Conventions","text":"<p>How to use brackets and ellipsis in supporting text quotes.</p>"},{"location":"concepts/editorial-conventions/#overview","title":"Overview","text":"<p>When citing scientific text, you often need to: - Add clarifications that weren't in the original - Omit portions of text between relevant parts</p> <p>linkml-reference-validator supports standard editorial conventions for these cases.</p>"},{"location":"concepts/editorial-conventions/#square-brackets","title":"Square Brackets <code>[...]</code>","text":"<p>Use square brackets to insert editorial clarifications that should be ignored during validation.</p>"},{"location":"concepts/editorial-conventions/#basic-usage","title":"Basic Usage","text":"<p>Reference text:</p> <pre><code>\"MUC1 oncoprotein blocks nuclear targeting of c-Abl\"\n</code></pre> <p>Your quote with clarification:</p> <pre><code>\"MUC1 [mucin 1] oncoprotein blocks nuclear targeting of c-Abl\"\n</code></pre> <p>The <code>[mucin 1]</code> is ignored during matching, so this validates successfully.</p>"},{"location":"concepts/editorial-conventions/#common-uses","title":"Common Uses","text":""},{"location":"concepts/editorial-conventions/#expanding-abbreviations","title":"Expanding Abbreviations","text":"<pre><code>Reference: \"TP53 functions in cell cycle regulation\"\nYour quote: \"TP53 [tumor protein p53] functions in cell cycle regulation\"\n</code></pre>"},{"location":"concepts/editorial-conventions/#adding-context","title":"Adding Context","text":"<pre><code>Reference: \"The protein blocks nuclear targeting\"\nYour quote: \"The protein [MUC1] blocks nuclear targeting\"\n</code></pre>"},{"location":"concepts/editorial-conventions/#clarifying-pronouns","title":"Clarifying Pronouns","text":"<pre><code>Reference: \"It regulates transcription\"\nYour quote: \"It [BRCA1] regulates transcription\"\n</code></pre>"},{"location":"concepts/editorial-conventions/#multiple-brackets","title":"Multiple Brackets","text":"<p>You can use multiple editorial notes in one quote:</p> <pre><code>\"The protein [MUC1] blocks nuclear targeting of c-Abl [a tyrosine kinase]\"\n</code></pre> <p>Both bracketed portions are removed before matching.</p>"},{"location":"concepts/editorial-conventions/#nested-brackets","title":"Nested Brackets","text":"<p>Nested brackets are not recommended and may not work as expected:</p> <pre><code>\u274c \"MUC1 [mucin 1 [a membrane protein]] blocks targeting\"\n\u2705 \"MUC1 [mucin 1, a membrane protein] blocks targeting\"\n</code></pre>"},{"location":"concepts/editorial-conventions/#ellipsis","title":"Ellipsis <code>...</code>","text":"<p>Use ellipsis (three dots) to indicate omitted text between parts of a quote.</p>"},{"location":"concepts/editorial-conventions/#basic-usage_1","title":"Basic Usage","text":"<p>Reference text:</p> <pre><code>\"MUC1 oncoprotein blocks nuclear targeting of c-Abl in the apoptotic response\"\n</code></pre> <p>Your quote with ellipsis:</p> <pre><code>\"MUC1 oncoprotein ... apoptotic response\"\n</code></pre> <p>Both parts must exist in the reference.</p>"},{"location":"concepts/editorial-conventions/#how-it-works","title":"How It Works","text":"<p>The validator: 1. Splits on <code>...</code> \u2192 <code>[\"MUC1 oncoprotein\", \"apoptotic response\"]</code> 2. Normalizes each part 3. Checks that both appear in the reference content 4. Returns valid only if both parts are found</p>"},{"location":"concepts/editorial-conventions/#common-uses_1","title":"Common Uses","text":""},{"location":"concepts/editorial-conventions/#removing-middle-content","title":"Removing Middle Content","text":"<pre><code>Reference: \"BRCA1 plays a critical role in DNA repair mechanisms through homologous recombination\"\nYour quote: \"BRCA1 plays a critical role in DNA repair ... homologous recombination\"\n</code></pre>"},{"location":"concepts/editorial-conventions/#extracting-key-points","title":"Extracting Key Points","text":"<pre><code>Reference: \"The MUC1 cytoplasmic domain, upon phosphorylation by Src kinases, interacts with \u03b2-catenin\"\nYour quote: \"MUC1 cytoplasmic domain ... interacts with \u03b2-catenin\"\n</code></pre>"},{"location":"concepts/editorial-conventions/#multiple-ellipses","title":"Multiple Ellipses","text":"<p>You can use multiple ellipses:</p> <pre><code>\"MUC1 ... blocks nuclear targeting ... apoptotic response\"\n</code></pre> <p>This creates three parts that must all be found.</p>"},{"location":"concepts/editorial-conventions/#order-matters","title":"Order Matters","text":"<p>The parts must appear in the reference in the same order:</p> <pre><code>Reference: \"A then B then C\"\n\n\u2705 \"A ... C\"        # Valid: A before C\n\u2705 \"A ... B ... C\"  # Valid: correct order\n\u274c \"C ... A\"        # Invalid: wrong order\n</code></pre>"},{"location":"concepts/editorial-conventions/#combining-conventions","title":"Combining Conventions","text":"<p>You can combine brackets and ellipsis:</p> <pre><code>\"MUC1 [mucin 1] oncoprotein ... c-Abl [a tyrosine kinase]\"\n</code></pre> <p>Processing order: 1. Remove brackets: <code>\"MUC1 oncoprotein ... c-Abl\"</code> 2. Split on ellipsis: <code>[\"MUC1 oncoprotein\", \"c-Abl\"]</code> 3. Normalize and match each part</p>"},{"location":"concepts/editorial-conventions/#best-practices","title":"Best Practices","text":""},{"location":"concepts/editorial-conventions/#do","title":"Do \u2705","text":"<ul> <li>Use brackets for actual editorial clarifications</li> <li>Use ellipsis only when omitting substantial text</li> <li>Keep your quotes as close to the original as practical</li> <li>Use these sparingly - direct quotes are clearer</li> </ul>"},{"location":"concepts/editorial-conventions/#dont","title":"Don't \u274c","text":"<ul> <li>Don't use brackets for emphasis or comments</li> <li>Don't use ellipsis for single word omissions</li> <li>Don't change the meaning with your insertions</li> <li>Don't nest brackets or use non-standard notation</li> </ul>"},{"location":"concepts/editorial-conventions/#examples","title":"Examples","text":"<p>Good usage:</p> <pre><code>supporting_text: BRCA1 [breast cancer 1] plays a role in DNA repair\nreference: PMID:12345678\n</code></pre> <p>Questionable usage:</p> <pre><code>supporting_text: BRCA1 [IMPORTANT!] plays a role in DNA repair  # \u274c Not editorial\nsupporting_text: BRCA1 plays a ... in DNA repair                # \u274c Unnecessary ellipsis\n</code></pre>"},{"location":"concepts/editorial-conventions/#command-line-examples","title":"Command Line Examples","text":""},{"location":"concepts/editorial-conventions/#with-brackets","title":"With Brackets","text":"<pre><code>linkml-reference-validator validate text \\\n  'MUC1 [mucin 1] oncoprotein blocks nuclear targeting' \\\n  PMID:16888623\n</code></pre> <p>Note: Use single quotes in shell to avoid bracket expansion.</p>"},{"location":"concepts/editorial-conventions/#with-ellipsis","title":"With Ellipsis","text":"<pre><code>linkml-reference-validator validate text \\\n  \"MUC1 oncoprotein ... apoptotic response\" \\\n  PMID:16888623\n</code></pre>"},{"location":"concepts/editorial-conventions/#combined","title":"Combined","text":"<pre><code>linkml-reference-validator validate text \\\n  'MUC1 [an oncoprotein] blocks ... c-Abl [a tyrosine kinase]' \\\n  PMID:16888623\n</code></pre>"},{"location":"concepts/editorial-conventions/#in-data-files","title":"In Data Files","text":"<p>Editorial conventions work the same in data files:</p> <pre><code>- gene_symbol: MUC1\n  function: oncoprotein blocking c-Abl\n  supporting_text: MUC1 [mucin 1] oncoprotein ... c-Abl\n  reference: PMID:16888623\n</code></pre>"},{"location":"concepts/editorial-conventions/#technical-details","title":"Technical Details","text":""},{"location":"concepts/editorial-conventions/#normalization-order","title":"Normalization Order","text":"<ol> <li>Remove everything inside <code>[...]</code></li> <li>Split on <code>...</code> if present</li> <li>For each part:</li> <li>Lowercase</li> <li>Remove punctuation</li> <li>Collapse whitespace</li> <li>Match normalized parts against normalized reference</li> </ol>"},{"location":"concepts/editorial-conventions/#regular-expressions","title":"Regular Expressions","text":"<p>Brackets: <code>\\[([^\\]]*)\\]</code> (removes content and brackets) Ellipsis: <code>\\.\\.\\.</code> (splits on three dots exactly)</p> <p>Note: <code>..</code> (two dots) and <code>....</code> (four dots) are NOT treated as ellipsis.</p>"},{"location":"concepts/editorial-conventions/#see-also","title":"See Also","text":"<ul> <li>How It Works - Understanding the validation process</li> <li>Tutorial 1 - Examples in practice</li> </ul>"},{"location":"concepts/how-it-works/","title":"How It Works","text":"<p>Understanding the validation process and design decisions.</p>"},{"location":"concepts/how-it-works/#overview","title":"Overview","text":"<p>linkml-reference-validator validates that quoted text (supporting text) actually appears in cited references. It uses deterministic substring matching rather than fuzzy or AI-based approaches.</p>"},{"location":"concepts/how-it-works/#the-validation-process","title":"The Validation Process","text":""},{"location":"concepts/how-it-works/#1-text-normalization","title":"1. Text Normalization","text":"<p>Before matching, both the supporting text and reference content are normalized:</p> <ul> <li>Lowercased: <code>\"MUC1\"</code> \u2192 <code>\"muc1\"</code></li> <li>Punctuation removed: <code>\"c-Abl\"</code> \u2192 <code>\"c abl\"</code></li> <li>Whitespace collapsed: Multiple spaces become single space</li> <li>Editorial notes removed: <code>\"[mucin 1]\"</code> \u2192 <code>\"\"</code></li> </ul> <p>Example:</p> <pre><code>Original: \"MUC1 [mucin 1] oncoprotein blocks c-Abl!!!\"\nNormalized: \"muc1 oncoprotein blocks c abl\"\n</code></pre> <p>This allows matching despite formatting differences while maintaining exactness.</p>"},{"location":"concepts/how-it-works/#2-substring-matching","title":"2. Substring Matching","text":"<p>After normalization, the validator checks if the supporting text appears as a substring in the reference content.</p> <p>Simple case:</p> <pre><code>supporting_text = \"MUC1 oncoprotein\"\nreference_content = \"...The MUC1 oncoprotein blocks nuclear...\"\n# Match: \"muc1 oncoprotein\" found in normalized reference\n</code></pre>"},{"location":"concepts/how-it-works/#3-ellipsis-handling","title":"3. Ellipsis Handling","text":"<p>When supporting text contains <code>...</code>, each part is matched separately:</p> <pre><code>Supporting: \"MUC1 oncoprotein ... nuclear targeting\"\nParts: [\"MUC1 oncoprotein\", \"nuclear targeting\"]\n# Both parts must exist in the reference\n</code></pre>"},{"location":"concepts/how-it-works/#4-title-validation","title":"4. Title Validation","text":"<p>In addition to excerpt/quote validation, the validator can verify reference titles using exact matching (not substring). Titles are validated when:</p> <ul> <li>A slot implements <code>dcterms:title</code> or has <code>slot_uri: dcterms:title</code></li> <li>A slot is named <code>title</code> (fallback)</li> </ul> <p>Example:</p> <pre><code>reference_title: \"MUC1 oncoprotein blocks nuclear targeting of c-Abl\"\n</code></pre> <p>Title matching uses the same normalization as excerpts (case, whitespace, punctuation, Greek letters) but requires the entire title to match, not just a substring.</p> <pre><code># These match after normalization:\nexpected = \"Role of JAK1 in Cell-Signaling\"\nactual = \"Role of JAK1 in Cell Signaling\"\n# Both normalize to: \"role of jak1 in cell signaling\"\n\n# These do NOT match (partial title):\nexpected = \"Role of JAK1\"  # Missing \"in Cell Signaling\"\nactual = \"Role of JAK1 in Cell Signaling\"\n</code></pre> <p>See Validating Reference Titles for detailed usage.</p>"},{"location":"concepts/how-it-works/#why-deterministic-matching","title":"Why Deterministic Matching?","text":""},{"location":"concepts/how-it-works/#not-fuzzy-matching","title":"Not Fuzzy Matching","text":"<p>We explicitly avoid fuzzy/similarity matching because:</p> <ol> <li>Accuracy: No false positives from \"close enough\" matches</li> <li>Reproducibility: Same input always gives same result</li> <li>Explainability: Clear why something matched or didn't</li> <li>Trust: Critical for scientific accuracy</li> </ol>"},{"location":"concepts/how-it-works/#not-ai-based","title":"Not AI-Based","text":"<p>We don't use LLMs or semantic similarity because:</p> <ol> <li>Determinism: Results must be reproducible</li> <li>Verifiability: Humans can verify the match themselves</li> <li>No hallucinations: The text either exists or doesn't</li> <li>Simplicity: No model dependencies or API costs</li> </ol>"},{"location":"concepts/how-it-works/#reference-fetching","title":"Reference Fetching","text":"<p>The validator uses a plugin architecture to support multiple reference sources. Each source type is handled by a dedicated plugin that knows how to fetch and parse content from that source.</p>"},{"location":"concepts/how-it-works/#pubmed-pmid","title":"PubMed (PMID)","text":"<p>For <code>PMID:12345678</code>:</p> <ol> <li>Queries NCBI E-utilities API</li> <li>Fetches abstract and metadata</li> <li>Parses XML response</li> <li>Caches as markdown with YAML frontmatter</li> </ol>"},{"location":"concepts/how-it-works/#pubmed-central-pmc","title":"PubMed Central (PMC)","text":"<p>For <code>PMC:12345</code>:</p> <ol> <li>Queries PMC API for full-text XML</li> <li>Extracts all sections (abstract, introduction, methods, results, discussion)</li> <li>Provides more content than abstracts alone</li> <li>Also cached as markdown</li> </ol>"},{"location":"concepts/how-it-works/#doi-digital-object-identifier","title":"DOI (Digital Object Identifier)","text":"<p>For <code>DOI:10.1234/example</code>:</p> <ol> <li>Queries Crossref API</li> <li>Fetches metadata and abstract (when available)</li> <li>Caches as markdown</li> </ol>"},{"location":"concepts/how-it-works/#local-files","title":"Local Files","text":"<p>For <code>file:./path/to/document.md</code>:</p> <ol> <li>Reads file from local filesystem</li> <li>Extracts title from first markdown heading (or uses filename)</li> <li>Content used as-is (no parsing for HTML files)</li> <li>Caches to allow consistent validation</li> </ol> <p>Path resolution: - Absolute paths work directly - Relative paths use <code>reference_base_dir</code> config if set, otherwise current directory</p>"},{"location":"concepts/how-it-works/#urls","title":"URLs","text":"<p>For <code>url:https://example.com/page</code>:</p> <ol> <li>Fetches page via HTTP GET</li> <li>Extracts title from <code>&lt;title&gt;</code> tag (for HTML)</li> <li>Content preserved as-is</li> <li>Cached like other sources</li> </ol>"},{"location":"concepts/how-it-works/#caching","title":"Caching","text":"<p>References are cached in <code>references_cache/</code> as markdown files:</p> <pre><code>references_cache/\n  PMID_16888623.md\n  PMC_3458566.md\n</code></pre> <p>Cache file format:</p> <pre><code>---\nreference_id: PMID:16888623\ntitle: MUC1 oncoprotein blocks nuclear targeting...\nauthors:\n  - Raina D\n  - Ahmad R\njournal: Molecular Cell\nyear: '2006'\ndoi: 10.1016/j.molcel.2006.04.017\ncontent_type: abstract_only\n---\n\n# MUC1 oncoprotein blocks nuclear targeting...\n\n**Authors:** Raina D, Ahmad R, ...\n**Journal:** Molecular Cell (2006)\n\n## Content\n\nThe MUC1 oncoprotein blocks nuclear targeting...\n</code></pre>"},{"location":"concepts/how-it-works/#cache-benefits","title":"Cache Benefits","text":"<ul> <li>Offline usage: Work without network after initial fetch</li> <li>Performance: Instant validation after first fetch</li> <li>Reproducibility: Same reference version for all validations</li> <li>Inspection: Human-readable cache files</li> </ul>"},{"location":"concepts/how-it-works/#linkml-integration","title":"LinkML Integration","text":"<p>The validator is a LinkML plugin that uses special slot URIs:</p> <pre><code>classes:\n  Statement:\n    attributes:\n      supporting_text:\n        slot_uri: linkml:excerpt  # Marks as quoted text\n      reference:\n        slot_uri: linkml:authoritative_reference  # Marks as reference ID\n      reference_title:\n        slot_uri: dcterms:title  # Marks as reference title (optional)\n</code></pre> <p>When LinkML validates data, it calls our plugin for fields marked with these URIs.</p> <p>The plugin discovers fields via: - <code>implements</code> attribute (e.g., <code>implements: [dcterms:title]</code>) - <code>slot_uri</code> attribute (e.g., <code>slot_uri: dcterms:title</code>) - Fallback slot names (<code>reference</code>, <code>supporting_text</code>, <code>title</code>)</p>"},{"location":"concepts/how-it-works/#editorial-conventions","title":"Editorial Conventions","text":""},{"location":"concepts/how-it-works/#square-brackets","title":"Square Brackets <code>[...]</code>","text":"<p>Used for editorial clarifications inserted into quotes:</p> <pre><code>Original reference: \"MUC1 oncoprotein blocks nuclear targeting\"\nYour quote: \"MUC1 [mucin 1] oncoprotein blocks nuclear targeting\"\n</code></pre> <p>The <code>[mucin 1]</code> is removed before matching.</p>"},{"location":"concepts/how-it-works/#ellipsis","title":"Ellipsis <code>...</code>","text":"<p>Used to indicate omitted text between parts:</p> <pre><code>Original: \"MUC1 oncoprotein blocks nuclear targeting of c-Abl\"\nYour quote: \"MUC1 oncoprotein ... c-Abl\"\n</code></pre> <p>Both parts must exist in the reference.</p>"},{"location":"concepts/how-it-works/#design-principles","title":"Design Principles","text":""},{"location":"concepts/how-it-works/#1-conservative-by-default","title":"1. Conservative by Default","text":"<ul> <li>Only exact substring matches count</li> <li>No approximations or suggestions</li> <li>Fail fast on mismatches</li> </ul>"},{"location":"concepts/how-it-works/#2-progressive-disclosure","title":"2. Progressive Disclosure","text":"<ul> <li>Simple cases require minimal syntax</li> <li>Advanced features (editorial notes, ellipsis) available when needed</li> <li>Sensible defaults (cache location, etc.)</li> </ul>"},{"location":"concepts/how-it-works/#3-cli-first","title":"3. CLI-First","text":"<ul> <li>Command-line is the primary interface</li> <li>Python API available for integration</li> <li>No GUI required</li> </ul>"},{"location":"concepts/how-it-works/#4-standards-based","title":"4. Standards-Based","text":"<ul> <li>Uses LinkML schemas</li> <li>NCBI standard identifiers (PMID, PMC)</li> <li>Markdown for cache files</li> </ul>"},{"location":"concepts/how-it-works/#limitations","title":"Limitations","text":""},{"location":"concepts/how-it-works/#what-this-tool-does-not-do","title":"What This Tool Does NOT Do","text":"<ul> <li>Semantic matching: Won't match paraphrases</li> <li>Citation formatting: Not a bibliography manager</li> <li>Fact checking: Only verifies text existence</li> <li>Plagiarism detection: Not designed for that purpose</li> </ul>"},{"location":"concepts/how-it-works/#known-limitations","title":"Known Limitations","text":"<ul> <li>Abstracts only for most PMIDs: Full text requires PMC. When validation fails and only an abstract was available, the error message will note this - the excerpt may exist in the full text.</li> <li>Network required: For initial reference fetch</li> <li>English-focused: Normalization optimized for English text</li> <li>No OCR: Can't extract text from images/PDFs in papers</li> </ul>"},{"location":"concepts/how-it-works/#when-to-use-this-tool","title":"When to Use This Tool","text":""},{"location":"concepts/how-it-works/#good-use-cases","title":"Good Use Cases \u2705","text":"<ul> <li>Validating gene function claims in databases</li> <li>Checking supporting text in knowledge graphs</li> <li>Verifying quotes in scientific documentation</li> <li>Batch validation of curated annotations</li> </ul>"},{"location":"concepts/how-it-works/#not-recommended","title":"Not Recommended \u274c","text":"<ul> <li>Checking if ideas are supported (use human review)</li> <li>Finding similar papers (use search engines)</li> <li>Generating citations (use citation managers)</li> <li>Paraphrase detection (use plagiarism tools)</li> </ul>"},{"location":"how-to/add-reference-source/","title":"Adding a Custom Reference Source","text":"<p>This guide shows how to add support for new reference types. There are two approaches:</p> <ol> <li>YAML Configuration (recommended) - Define sources via config files, no Python required</li> <li>Python Plugin - Create a custom Python class for complex sources</li> </ol>"},{"location":"how-to/add-reference-source/#yaml-configuration-recommended","title":"YAML Configuration (Recommended)","text":"<p>For sources that expose a JSON API, you can define them entirely through YAML configuration. No Python code required, no pull requests needed.</p>"},{"location":"how-to/add-reference-source/#understanding-the-config-files","title":"Understanding the Config Files","text":"<p>The validator uses two separate config files:</p> File Purpose <code>.linkml-reference-validator.yaml</code> Main config: cache settings, skip_prefixes, rate limiting <code>.linkml-reference-validator-sources.yaml</code> Custom sources: JSON API definitions"},{"location":"how-to/add-reference-source/#quick-start","title":"Quick Start","text":"<p>Create a file named <code>.linkml-reference-validator-sources.yaml</code> in your project root:</p> <pre><code>sources:\n  MGNIFY:\n    url_template: \"https://www.ebi.ac.uk/metagenomics/api/v1/studies/{id}\"\n    fields:\n      title: \"$.data.attributes.study-name\"\n      content: \"$.data.attributes.study-abstract\"\n    id_patterns:\n      - \"^MGYS\\\\d+$\"\n</code></pre> <p>Now you can validate MGnify references:</p> <pre><code>linkml-reference-validator validate text \\\n  \"The American Gut Project\" \\\n  MGNIFY:MGYS00000596\n</code></pre>"},{"location":"how-to/add-reference-source/#configuration-file-locations","title":"Configuration File Locations","text":"<p>Sources are loaded from these locations (in order of priority):</p> <ol> <li><code>~/.config/linkml-reference-validator/sources/*.yaml</code> (user-level)</li> <li><code>.linkml-reference-validator-sources.yaml</code> (project-level)</li> <li><code>sources:</code> section in your main config file</li> </ol>"},{"location":"how-to/add-reference-source/#source-configuration-fields","title":"Source Configuration Fields","text":"Field Required Description <code>url_template</code> Yes API URL with <code>{id}</code> placeholder <code>fields</code> Yes JSONPath expressions mapping to title, content, etc. <code>id_patterns</code> No Regex patterns for bare ID matching <code>headers</code> No HTTP headers (supports <code>${ENV_VAR}</code> interpolation) <code>store_raw_response</code> No Store full API response in metadata"},{"location":"how-to/add-reference-source/#field-mappings","title":"Field Mappings","text":"<p>Use JSONPath expressions (using jsonpath-ng syntax) to extract fields from the API response:</p> <pre><code>sources:\n  EXAMPLE:\n    url_template: \"https://api.example.com/items/{id}\"\n    fields:\n      title: \"$.name\"           # Simple field\n      content: \"$.description\"   # Abstract/description\n      year: \"$.published_date\"   # Optional: publication year\n      authors: \"$.authors[0].name\"  # Optional: author info\n</code></pre> <p>Standard field names: <code>title</code>, <code>content</code>, <code>year</code>, <code>authors</code>, <code>journal</code>, <code>doi</code></p>"},{"location":"how-to/add-reference-source/#jsonpath-examples","title":"JSONPath Examples","text":"<p>Common JSONPath patterns:</p> Pattern Description <code>$.title</code> Top-level field <code>$.data.attributes.name</code> Nested field <code>$.items[0]</code> First array element <code>$.results[*].name</code> All names in array"},{"location":"how-to/add-reference-source/#id-pattern-matching","title":"ID Pattern Matching","text":"<p>Use <code>id_patterns</code> to match bare IDs (without prefix):</p> <pre><code>sources:\n  MGNIFY:\n    url_template: \"https://www.ebi.ac.uk/metagenomics/api/v1/studies/{id}\"\n    fields:\n      title: \"$.data.attributes.study-name\"\n      content: \"$.data.attributes.study-abstract\"\n    id_patterns:\n      - \"^MGYS\\\\d+$\"    # Matches MGYS00000596\n      - \"^MGY[A-Z]\\\\d+$\"  # Matches MGYA123456\n</code></pre> <p>With this config, both formats work:</p> <pre><code># With prefix\nlinkml-reference-validator validate text \"quote\" MGNIFY:MGYS00000596\n\n# Bare ID (matched by pattern)\nlinkml-reference-validator validate text \"quote\" MGYS00000596\n</code></pre>"},{"location":"how-to/add-reference-source/#authentication","title":"Authentication","text":"<p>For APIs requiring authentication, use environment variables:</p> <pre><code>sources:\n  PRIVATE_API:\n    url_template: \"https://api.example.com/records/{id}\"\n    fields:\n      title: \"$.title\"\n      content: \"$.body\"\n    headers:\n      Authorization: \"Bearer ${API_TOKEN}\"\n      X-API-Key: \"${API_KEY}\"\n</code></pre> <p>Set the environment variable before running:</p> <pre><code>export API_TOKEN=\"your-secret-token\"\nlinkml-reference-validator validate text \"quote\" PRIVATE_API:123\n</code></pre>"},{"location":"how-to/add-reference-source/#storing-raw-response","title":"Storing Raw Response","text":"<p>Enable <code>store_raw_response</code> to capture the full API response in metadata:</p> <pre><code>sources:\n  MGNIFY:\n    url_template: \"https://www.ebi.ac.uk/metagenomics/api/v1/studies/{id}\"\n    fields:\n      title: \"$.data.attributes.study-name\"\n      content: \"$.data.attributes.study-abstract\"\n    store_raw_response: true\n</code></pre> <p>The raw response is saved in the cache file's metadata for later inspection.</p>"},{"location":"how-to/add-reference-source/#complete-example-mgnify","title":"Complete Example: MGnify","text":"<p>Here's a complete configuration for MGnify (EBI Metagenomics):</p> <pre><code># .linkml-reference-validator-sources.yaml\nsources:\n  MGNIFY:\n    url_template: \"https://www.ebi.ac.uk/metagenomics/api/v1/studies/{id}\"\n    id_patterns:\n      - \"^MGYS\\\\d+$\"\n    fields:\n      title: \"$.data.attributes.study-name\"\n      content: \"$.data.attributes.study-abstract\"\n    headers:\n      Accept: \"application/json\"\n    store_raw_response: true\n</code></pre> <p>Test it:</p> <pre><code># Cache the reference\nlinkml-reference-validator cache reference MGNIFY:MGYS00000596\n\n# Validate a quote\nlinkml-reference-validator validate text \\\n  \"The American Gut project is the largest crowdsourced citizen science project\" \\\n  MGNIFY:MGYS00000596\n</code></pre>"},{"location":"how-to/add-reference-source/#complete-example-biostudies","title":"Complete Example: BioStudies","text":"<pre><code>sources:\n  BIOSTUDIES:\n    url_template: \"https://www.ebi.ac.uk/biostudies/api/v1/studies/{id}\"\n    id_patterns:\n      - \"^S-[A-Z]+\\\\d+$\"\n    fields:\n      title: \"$.title\"\n      content: \"$.description\"\n</code></pre>"},{"location":"how-to/add-reference-source/#complete-setup-both-config-files","title":"Complete Setup: Both Config Files","text":"<p>Here's a typical project setup showing both config files working together. The pattern is: skip what you can't support, configure what you can.</p> <p><code>.linkml-reference-validator.yaml</code> (main config):</p> <pre><code># Main validation settings\ncache_dir: references_cache\nrate_limit_delay: 0.5\n\n# Skip prefixes that have no API or aren't needed\nskip_prefixes:\n  - SRA        # No abstract API available\n  - ARRAYEXPRESS  # Deprecated, use BioStudies\n\n# Note: Once you add a custom source for a prefix (like MGNIFY below),\n# remove it from skip_prefixes - validation will now work properly.\n</code></pre> <p><code>.linkml-reference-validator-sources.yaml</code> (custom sources):</p> <pre><code># Custom JSON API sources\nsources:\n  MGNIFY:\n    url_template: \"https://www.ebi.ac.uk/metagenomics/api/v1/studies/{id}\"\n    id_patterns:\n      - \"^MGYS\\\\d+$\"\n    fields:\n      title: \"$.data.attributes.study-name\"\n      content: \"$.data.attributes.study-abstract\"\n\n  BIOSTUDIES:\n    url_template: \"https://www.ebi.ac.uk/biostudies/api/v1/studies/{id}\"\n    id_patterns:\n      - \"^S-[A-Z]+\\\\d+$\"\n    fields:\n      title: \"$.title\"\n      content: \"$.description\"\n</code></pre> <p>With this setup: - <code>PMID:12345</code> - Uses built-in PubMed source - <code>MGNIFY:MGYS00000596</code> - Uses your custom MGnify source - <code>SRA:SRP123456</code> - Skipped (returns valid with INFO message)</p>"},{"location":"how-to/add-reference-source/#finding-the-right-jsonpath","title":"Finding the Right JSONPath","text":"<p>To figure out the correct JSONPath for a new API:</p> <ol> <li> <p>Fetch the API response directly:    <code>bash    curl -s \"https://api.example.com/items/123\" | jq .</code></p> </li> <li> <p>Identify the fields you need (title, description/abstract)</p> </li> <li> <p>Write the JSONPath:</p> </li> <li><code>$.fieldname</code> for top-level fields</li> <li><code>$.parent.child</code> for nested fields</li> <li><code>$.array[0]</code> for array elements</li> </ol>"},{"location":"how-to/add-reference-source/#python-plugin-advanced","title":"Python Plugin (Advanced)","text":"<p>For sources requiring custom logic (XML parsing, multiple API calls, etc.), create a Python plugin.</p>"},{"location":"how-to/add-reference-source/#overview","title":"Overview","text":"<p>Each reference source is a Python class that:</p> <ol> <li>Inherits from <code>ReferenceSource</code></li> <li>Implements <code>prefix()</code> and <code>fetch()</code> methods</li> <li>Registers itself with the <code>ReferenceSourceRegistry</code></li> </ol>"},{"location":"how-to/add-reference-source/#entrez-summary-sources-recommended-for-ncbi-ids","title":"Entrez Summary Sources (Recommended for NCBI IDs)","text":"<p>If your source is backed by NCBI Entrez, prefer the built-in <code>EntrezSummarySource</code> base class. It provides shared rate limiting, email configuration, and summary parsing.</p> <pre><code># src/linkml_reference_validator/etl/sources/my_entrez.py\n\"\"\"Entrez summary source example.\"\"\"\n\nfrom linkml_reference_validator.etl.sources.entrez import EntrezSummarySource\nfrom linkml_reference_validator.etl.sources.base import ReferenceSourceRegistry\n\n\n@ReferenceSourceRegistry.register\nclass ExampleEntrezSource(EntrezSummarySource):\n    \"\"\"Fetch summaries from an Entrez database.\"\"\"\n\n    PREFIX = \"EXAMPLE\"\n    ENTREZ_DB = \"example_db\"\n    TITLE_FIELDS = (\"title\", \"name\")\n    CONTENT_FIELDS = (\"summary\", \"description\")\n    ID_PATTERNS = (r\"^EX\\\\d+$\",)\n</code></pre> <p><code>TITLE_FIELDS</code> and <code>CONTENT_FIELDS</code> are checked in order, and the first non-empty value is used for the <code>ReferenceContent</code>.</p>"},{"location":"how-to/add-reference-source/#step-1-create-the-source-class","title":"Step 1: Create the Source Class","text":"<p>Create a new file in <code>src/linkml_reference_validator/etl/sources/</code>:</p> <pre><code># src/linkml_reference_validator/etl/sources/arxiv.py\n\"\"\"arXiv reference source.\"\"\"\n\nimport logging\nfrom typing import Optional\n\nfrom linkml_reference_validator.models import ReferenceContent, ReferenceValidationConfig\nfrom linkml_reference_validator.etl.sources.base import ReferenceSource, ReferenceSourceRegistry\n\nlogger = logging.getLogger(__name__)\n\n\n@ReferenceSourceRegistry.register\nclass ArxivSource(ReferenceSource):\n    \"\"\"Fetch references from arXiv.\"\"\"\n\n    @classmethod\n    def prefix(cls) -&gt; str:\n        \"\"\"Return the prefix this source handles.\"\"\"\n        return \"arxiv\"\n\n    def fetch(\n        self, identifier: str, config: ReferenceValidationConfig\n    ) -&gt; Optional[ReferenceContent]:\n        \"\"\"Fetch a paper from arXiv.\n\n        Args:\n            identifier: arXiv ID (e.g., '2301.07041')\n            config: Configuration for fetching\n\n        Returns:\n            ReferenceContent if successful, None otherwise\n        \"\"\"\n        # Your implementation here\n        # Fetch from arXiv API, parse response, return ReferenceContent\n        ...\n</code></pre>"},{"location":"how-to/add-reference-source/#step-2-implement-the-fetch-method","title":"Step 2: Implement the <code>fetch()</code> Method","text":"<p>The <code>fetch()</code> method should:</p> <ol> <li>Accept an identifier (without the prefix)</li> <li>Fetch content from the external source</li> <li>Return a <code>ReferenceContent</code> object or <code>None</code> on failure</li> </ol> <pre><code>def fetch(\n    self, identifier: str, config: ReferenceValidationConfig\n) -&gt; Optional[ReferenceContent]:\n    \"\"\"Fetch a paper from arXiv.\"\"\"\n    import requests\n    import time\n\n    arxiv_id = identifier.strip()\n\n    # Respect rate limiting\n    time.sleep(config.rate_limit_delay)\n\n    # Fetch from arXiv API\n    url = f\"http://export.arxiv.org/api/query?id_list={arxiv_id}\"\n    response = requests.get(url, timeout=30)\n\n    if response.status_code != 200:\n        logger.warning(f\"Failed to fetch arxiv:{arxiv_id}\")\n        return None\n\n    # Parse the response (arXiv returns Atom XML)\n    title, authors, abstract = self._parse_arxiv_response(response.text)\n\n    return ReferenceContent(\n        reference_id=f\"arxiv:{arxiv_id}\",\n        title=title,\n        content=abstract,\n        content_type=\"abstract_only\",\n        authors=authors,\n    )\n</code></pre>"},{"location":"how-to/add-reference-source/#step-3-register-the-source","title":"Step 3: Register the Source","text":"<p>Add the import to <code>src/linkml_reference_validator/etl/sources/__init__.py</code>:</p> <pre><code>from linkml_reference_validator.etl.sources.arxiv import ArxivSource\n\n__all__ = [\n    # ... existing exports\n    \"ArxivSource\",\n]\n</code></pre>"},{"location":"how-to/add-reference-source/#step-4-write-tests","title":"Step 4: Write Tests","text":"<p>Create tests in <code>tests/test_sources.py</code>:</p> <pre><code>class TestArxivSource:\n    \"\"\"Tests for ArxivSource.\"\"\"\n\n    @pytest.fixture\n    def source(self):\n        return ArxivSource()\n\n    def test_prefix(self, source):\n        assert source.prefix() == \"arxiv\"\n\n    def test_can_handle(self, source):\n        assert source.can_handle(\"arxiv:2301.07041\")\n        assert not source.can_handle(\"PMID:12345\")\n\n    @patch(\"linkml_reference_validator.etl.sources.arxiv.requests.get\")\n    def test_fetch(self, mock_get, source, config):\n        mock_response = MagicMock()\n        mock_response.status_code = 200\n        mock_response.text = \"\"\"...\"\"\"  # Mock arXiv XML\n        mock_get.return_value = mock_response\n\n        result = source.fetch(\"2301.07041\", config)\n\n        assert result is not None\n        assert result.reference_id == \"arxiv:2301.07041\"\n</code></pre>"},{"location":"how-to/add-reference-source/#reference-referencecontent-fields","title":"Reference: ReferenceContent Fields","text":"<p>The <code>ReferenceContent</code> model has these fields:</p> Field Type Description <code>reference_id</code> <code>str</code> Full reference ID with prefix (e.g., <code>arxiv:2301.07041</code>) <code>title</code> <code>Optional[str]</code> Title of the reference <code>content</code> <code>Optional[str]</code> Main text content for validation <code>content_type</code> <code>str</code> Type indicator (e.g., <code>abstract_only</code>, <code>full_text</code>) <code>authors</code> <code>Optional[list[str]]</code> List of author names <code>journal</code> <code>Optional[str]</code> Journal/venue name <code>year</code> <code>Optional[str]</code> Publication year <code>doi</code> <code>Optional[str]</code> DOI if available <code>metadata</code> <code>dict</code> Additional metadata (raw API response, etc.)"},{"location":"how-to/add-reference-source/#tips","title":"Tips","text":"<ul> <li>Rate limiting: Always respect <code>config.rate_limit_delay</code> between API calls</li> <li>Error handling: Return <code>None</code> on failures, don't raise exceptions</li> <li>Logging: Use <code>logger.warning()</code> for failures to aid debugging</li> <li>Caching: The <code>ReferenceFetcher</code> handles caching automatically - your source just needs to fetch</li> <li>Testing: Mock external API calls in tests to avoid network dependencies</li> </ul>"},{"location":"how-to/repair-validation-errors/","title":"How to Repair Validation Errors","text":"<p>This guide explains how to use the <code>repair</code> command to automatically fix or flag supporting text validation errors.</p>"},{"location":"how-to/repair-validation-errors/#overview","title":"Overview","text":"<p>After validating your data files, you may find validation errors due to:</p> <ol> <li>Minor text differences - Unicode/ASCII variations (CO2 vs CO\u2082)</li> <li>Missing ellipsis connectors - Non-contiguous text without <code>...</code> separators</li> <li>Fabricated snippets - Text that doesn't appear in the reference</li> <li>Missing abstracts - References without available content</li> </ol> <p>The <code>repair</code> command attempts to fix these issues automatically or flags them for manual review.</p>"},{"location":"how-to/repair-validation-errors/#quick-start","title":"Quick Start","text":""},{"location":"how-to/repair-validation-errors/#repair-a-single-quote","title":"Repair a Single Quote","text":"<pre><code>linkml-reference-validator repair text \"CO2 levels were measured\" PMID:12345678\n</code></pre> <p>Output:</p> <pre><code>\u2713 Repaired successfully\n  Original: CO2 levels were measured\n  Repaired: CO\u2082 levels were measured\n  Action: CHARACTER_NORMALIZATION\n  Confidence: HIGH\n</code></pre>"},{"location":"how-to/repair-validation-errors/#repair-a-data-file-dry-run","title":"Repair a Data File (Dry Run)","text":"<pre><code>linkml-reference-validator repair data disease.yaml \\\n  --schema schema.yaml \\\n  --dry-run\n</code></pre>"},{"location":"how-to/repair-validation-errors/#apply-repairs","title":"Apply Repairs","text":"<pre><code>linkml-reference-validator repair data disease.yaml \\\n  --schema schema.yaml \\\n  --no-dry-run\n</code></pre>"},{"location":"how-to/repair-validation-errors/#understanding-confidence-levels","title":"Understanding Confidence Levels","text":"<p>The repair command uses confidence thresholds to determine how to handle each error:</p> Confidence Score Range Action HIGH 0.95-1.00 Auto-fix safely MEDIUM 0.80-0.95 Suggest fix, needs review LOW 0.50-0.80 Flag for manual review VERY_LOW 0.00-0.50 Recommend removal"},{"location":"how-to/repair-validation-errors/#repair-strategies","title":"Repair Strategies","text":""},{"location":"how-to/repair-validation-errors/#1-character-normalization-high-confidence","title":"1. Character Normalization (High Confidence)","text":"<p>Fixes common Unicode/ASCII differences automatically:</p> <p>Before:</p> <pre><code>supporting_text: \"CO2 levels were measured\"\n</code></pre> <p>After:</p> <pre><code>supporting_text: \"CO\u2082 levels were measured\"\n</code></pre> <p>Common mappings: - <code>CO2</code> \u2192 <code>CO\u2082</code> - <code>H2O</code> \u2192 <code>H\u2082O</code> - <code>O2</code> \u2192 <code>O\u2082</code> - <code>+/-</code> \u2192 <code>\u00b1</code> - <code>+-</code> \u2192 <code>\u00b1</code></p>"},{"location":"how-to/repair-validation-errors/#2-ellipsis-insertion-medium-confidence","title":"2. Ellipsis Insertion (Medium Confidence)","text":"<p>When text parts exist in the reference but aren't contiguous:</p> <p>Before:</p> <pre><code>supporting_text: \"Disease X affects children. Treatment involves medication Y.\"\n</code></pre> <p>After:</p> <pre><code>supporting_text: \"Disease X affects children. ... Treatment involves medication Y.\"\n</code></pre> <p>This requires manual review because the context between parts may be important.</p>"},{"location":"how-to/repair-validation-errors/#3-fuzzy-match-correction-variable-confidence","title":"3. Fuzzy Match Correction (Variable Confidence)","text":"<p>Suggests the closest matching text from the reference:</p> <pre><code>Suggested fix (85%): \"Haemophilus influenzae type b\" \u2192 \"H. influenzae type b\"\n</code></pre> <p>Use with caution - verify the suggestion preserves the intended meaning.</p>"},{"location":"how-to/repair-validation-errors/#4-removal-recommendation-very-low-confidence","title":"4. Removal Recommendation (Very Low Confidence)","text":"<p>Flags text that appears fabricated or hallucinated:</p> <pre><code>RECOMMENDED REMOVALS:\n  PMID:34567890 at evidence[2]:\n    Similarity: 8%\n    Snippet: 'This completely made up text...'\n</code></pre> <p>Never auto-removed - always requires manual review.</p>"},{"location":"how-to/repair-validation-errors/#configuration-file","title":"Configuration File","text":"<p>Create <code>.linkml-reference-validator.yaml</code> for project-specific settings. You can include both validation and repair settings:</p> <pre><code>validation:\n  reference_prefix_map:\n    geo: GEO\n    NCBIGeo: GEO\n\nrepair:\n  # Confidence thresholds\n  auto_fix_threshold: 0.95\n  suggest_threshold: 0.80\n  removal_threshold: 0.50\n\n  # Character mappings\n  character_mappings:\n    \"+/-\": \"\u00b1\"\n    \"CO2\": \"CO\u2082\"\n    \"H2O\": \"H\u2082O\"\n    \"O2\": \"O\u2082\"\n    \"N2\": \"N\u2082\"\n\n  # References to skip (known issues)\n  skip_references:\n    - \"PMID:12345678\"\n\n  # References trusted despite low similarity\n  trusted_low_similarity:\n    - \"PMID:98765432\"\n</code></pre> <p>Use with:</p> <pre><code>linkml-reference-validator repair data file.yaml \\\n  --schema schema.yaml \\\n  --config .linkml-reference-validator.yaml\n</code></pre>"},{"location":"how-to/repair-validation-errors/#command-reference","title":"Command Reference","text":""},{"location":"how-to/repair-validation-errors/#repair-text","title":"<code>repair text</code>","text":"<p>Repair a single supporting text quote.</p> <pre><code>linkml-reference-validator repair text &lt;TEXT&gt; &lt;REFERENCE_ID&gt; [OPTIONS]\n</code></pre> <p>Options: - <code>--cache-dir PATH</code> - Directory for caching references - <code>--verbose</code> - Show detailed output - <code>--auto-fix-threshold FLOAT</code> - Minimum similarity for auto-fixes</p> <p>Examples:</p> <pre><code># Basic repair\nlinkml-reference-validator repair text \"CO2 levels\" PMID:12345678\n\n# With verbose output\nlinkml-reference-validator repair text \"protein functions\" PMID:12345678 --verbose\n\n# Custom threshold\nlinkml-reference-validator repair text \"text\" PMID:123 --auto-fix-threshold 0.98\n</code></pre>"},{"location":"how-to/repair-validation-errors/#repair-data","title":"<code>repair data</code>","text":"<p>Repair supporting text in a data file.</p> <pre><code>linkml-reference-validator repair data &lt;DATA_FILE&gt; --schema &lt;SCHEMA&gt; [OPTIONS]\n</code></pre> <p>Options: - <code>--schema PATH</code> - Path to LinkML schema (required) - <code>--target-class CLASS</code> - Target class to validate - <code>--dry-run / --no-dry-run</code> - Show changes without applying (default: dry-run) - <code>--auto-fix-threshold FLOAT</code> - Minimum similarity for auto-fixes (default: 0.95) - <code>--output PATH</code> - Output file path (default: overwrite with backup) - <code>--config PATH</code> - Path to repair configuration file - <code>--cache-dir PATH</code> - Directory for caching references - <code>--verbose</code> - Show detailed output</p> <p>Examples:</p> <pre><code># Dry run (default)\nlinkml-reference-validator repair data disease.yaml \\\n  --schema schema.yaml\n\n# Apply fixes\nlinkml-reference-validator repair data disease.yaml \\\n  --schema schema.yaml \\\n  --no-dry-run\n\n# Output to new file\nlinkml-reference-validator repair data disease.yaml \\\n  --schema schema.yaml \\\n  --no-dry-run \\\n  --output repaired.yaml\n\n# With custom config\nlinkml-reference-validator repair data disease.yaml \\\n  --schema schema.yaml \\\n  --config .linkml-reference-validator.yaml\n</code></pre>"},{"location":"how-to/repair-validation-errors/#best-practices","title":"Best Practices","text":""},{"location":"how-to/repair-validation-errors/#1-always-start-with-dry-run","title":"1. Always Start with Dry Run","text":"<pre><code># First, see what would be changed\nlinkml-reference-validator repair data file.yaml --schema schema.yaml --dry-run\n\n# Review the report carefully, then apply\nlinkml-reference-validator repair data file.yaml --schema schema.yaml --no-dry-run\n</code></pre>"},{"location":"how-to/repair-validation-errors/#2-review-suggested-fixes","title":"2. Review Suggested Fixes","text":"<p>High-confidence fixes (character normalization) are safe to auto-apply. But always review: - Ellipsis insertions (may lose important context) - Fuzzy corrections (may change meaning)</p>"},{"location":"how-to/repair-validation-errors/#3-handle-removals-manually","title":"3. Handle Removals Manually","text":"<p>Items flagged for removal are never automatically deleted. Review each one: - Verify the text isn't actually in the reference - Check if you have the wrong PMID - Consider finding an alternative reference</p>"},{"location":"how-to/repair-validation-errors/#4-use-skip-lists-for-known-issues","title":"4. Use Skip Lists for Known Issues","text":"<p>If a reference is known to have issues (no abstract, behind paywall), add it to skip list:</p> <pre><code>repair:\n  skip_references:\n    - \"PMID:12345678\"  # No abstract available\n</code></pre>"},{"location":"how-to/repair-validation-errors/#5-trust-list-for-verified-references","title":"5. Trust List for Verified References","text":"<p>If you've manually verified a low-similarity match is correct:</p> <pre><code>repair:\n  trusted_low_similarity:\n    - \"PMID:98765432\"  # Verified manually\n</code></pre>"},{"location":"how-to/repair-validation-errors/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/repair-validation-errors/#no-evidence-items-found-to-repair","title":"\"No evidence items found to repair\"","text":"<p>Your data file doesn't match the expected evidence structure. Ensure your schema has: - A field named <code>supporting_text</code> or <code>snippet</code> - A field named <code>reference</code> or <code>reference_id</code></p>"},{"location":"how-to/repair-validation-errors/#flagged-for-removal-text-not-found","title":"\"Flagged for removal - text not found\"","text":"<p>The supporting text wasn't found in the reference. Possible causes: - Text is paraphrased, not quoted - Text is in figures/tables (not extracted) - Wrong PMID - AI-generated/hallucinated quote</p>"},{"location":"how-to/repair-validation-errors/#reference-content-not-available","title":"\"Reference content not available\"","text":"<p>The reference exists but has no retrievable content: - Abstract-only paper with no PMC access - Very old paper - Retracted article</p> <p>Add to skip list to ignore during repair:</p> <pre><code>repair:\n  skip_references:\n    - \"PMID:NOABSTRACT001\"\n</code></pre>"},{"location":"how-to/repair-validation-errors/#validation-failed-with-only-abstract-available","title":"Validation Failed with \"only abstract available\"","text":"<p>When you see an error like:</p> <pre><code>Text part not found as substring: 'excerpt from methods section'\n(note: only abstract available for PMID:16888623, full text may contain this excerpt)\n</code></pre> <p>This means the excerpt may exist in the paper's full text, but only the abstract was accessible. Here's what to do:</p>"},{"location":"how-to/repair-validation-errors/#option-1-find-the-pmc-version","title":"Option 1: Find the PMC Version","text":"<p>Search PubMed Central for the article. If it has a PMC ID:</p> <pre><code># Instead of\nreference: PMID:16888623\n\n# Use\nreference: PMC:3458566\n</code></pre> <p>The validator will fetch full text from PMC automatically.</p>"},{"location":"how-to/repair-validation-errors/#option-2-use-a-local-file","title":"Option 2: Use a Local File","text":"<p>If you have access to the full text (PDF, HTML, or text):</p> <ol> <li>Save the text content as markdown:    ```bash    # Extract text from PDF (if you have one)    # Or copy/paste relevant sections    echo \"# Article Title</li> </ol> <p>Full text content here...\" &gt; papers/pmid_16888623.md    ```</p> <ol> <li>Reference the local file:    <code>yaml    reference: file:./papers/pmid_16888623.md</code></li> </ol> <p>See Using Local Files and URLs for details.</p>"},{"location":"how-to/repair-validation-errors/#option-3-use-a-url","title":"Option 3: Use a URL","text":"<p>If the full text is freely available online:</p> <pre><code>reference: url:https://example.com/full-text-article\n</code></pre>"},{"location":"how-to/repair-validation-errors/#option-4-remove-or-revise-the-excerpt","title":"Option 4: Remove or Revise the Excerpt","text":"<p>If the excerpt can't be verified:</p> <ul> <li>Remove it if it's not essential</li> <li>Shorten it to text that appears in the abstract</li> <li>Replace it with a verifiable quote from the abstract</li> </ul>"},{"location":"how-to/repair-validation-errors/#option-5-accept-the-limitation","title":"Option 5: Accept the Limitation","text":"<p>Document that certain excerpts couldn't be verified:</p> <pre><code>repair:\n  skip_references:\n    - \"PMID:16888623\"  # Full text not available, abstract verified manually\n</code></pre>"},{"location":"how-to/repair-validation-errors/#understanding-content-types","title":"Understanding Content Types","text":"<p>The <code>content_type</code> field in cached references tells you what content was retrieved:</p> Value What You Have Validation Reliability <code>full_text_xml</code> Full PMC article High - all sections available <code>full_text_html</code> Full PMC article (HTML) High - all sections available <code>abstract_only</code> Abstract only Limited - only abstract searchable <code>summary</code> Database summary Limited - brief description only <code>unavailable</code> Nothing None - validation will fail <p>Check content type with:</p> <pre><code>linkml-reference-validator cache lookup PMID:16888623 --content\n</code></pre> <p>See Content Types for full documentation.</p>"},{"location":"how-to/repair-validation-errors/#python-api","title":"Python API","text":"<p>For programmatic access:</p> <pre><code>from linkml_reference_validator.models import (\n    ReferenceValidationConfig,\n    RepairConfig,\n)\nfrom linkml_reference_validator.validation.repairer import SupportingTextRepairer\n\n# Configure\nval_config = ReferenceValidationConfig(cache_dir=\"cache\")\nrepair_config = RepairConfig(\n    auto_fix_threshold=0.95,\n    character_mappings={\"CO2\": \"CO\u2082\"},\n)\n\n# Create repairer\nrepairer = SupportingTextRepairer(val_config, repair_config)\n\n# Repair single item\nresult = repairer.repair_single(\n    supporting_text=\"CO2 levels were measured\",\n    reference_id=\"PMID:12345678\",\n)\n\nprint(f\"Repaired: {result.is_repaired}\")\nprint(f\"New text: {result.repaired_text}\")\n\n# Batch repair\nitems = [\n    (\"text1\", \"PMID:1\", \"path1\"),\n    (\"text2\", \"PMID:2\", \"path2\"),\n]\nreport = repairer.repair_batch(items)\nprint(repairer.format_report(report))\n</code></pre>"},{"location":"how-to/skip-unsupported-references/","title":"Skipping Unsupported Reference Types","text":"<p>When validating data that contains references from multiple sources, you may encounter reference types that aren't yet supported by the validator. Rather than failing validation entirely, you can configure the validator to skip or downgrade the severity for these references.</p>"},{"location":"how-to/skip-unsupported-references/#quick-start","title":"Quick Start","text":"<p>Create a <code>.linkml-reference-validator.yaml</code> file in your project root:</p> <pre><code>skip_prefixes:\n  - SRA\n  - MGNIFY\n  - BIOPROJECT\n\nunknown_prefix_severity: WARNING\n</code></pre> <p>Now references with these prefixes will be skipped, and any other unfetchable references will produce warnings instead of errors.</p>"},{"location":"how-to/skip-unsupported-references/#configuration-options","title":"Configuration Options","text":""},{"location":"how-to/skip-unsupported-references/#skip_prefixes","title":"skip_prefixes","text":"<p>A list of reference prefixes to skip entirely during validation. References with these prefixes will:</p> <ul> <li>Return <code>is_valid=True</code></li> <li>Have severity <code>INFO</code></li> <li>Not block validation</li> </ul> <pre><code>skip_prefixes:\n  - SRA        # NCBI Sequence Read Archive\n  - MGNIFY     # EBI Metagenomics\n  - BIOPROJECT # NCBI BioProject\n</code></pre> <p>Prefix matching is case-insensitive, so <code>sra</code>, <code>SRA</code>, and <code>Sra</code> all match.</p> <p>When to use: When you have legitimate references that the validator doesn't yet support, but you want to keep them in your data.</p>"},{"location":"how-to/skip-unsupported-references/#unknown_prefix_severity","title":"unknown_prefix_severity","text":"<p>Controls the severity level for references that cannot be fetched (unsupported prefix, network error, API failure). Does not apply to prefixes listed in <code>skip_prefixes</code>.</p> <p>Options: - <code>ERROR</code> (default) - Validation fails, exit code 1 - <code>WARNING</code> - Issue reported but validation passes - <code>INFO</code> - Minimal reporting, validation passes</p> <pre><code>unknown_prefix_severity: WARNING\n</code></pre> <p>When to use: When you want validation to continue even if some references can't be fetched, but still want to see which ones failed.</p>"},{"location":"how-to/skip-unsupported-references/#configuration-file-locations","title":"Configuration File Locations","text":"<p>The validator looks for configuration in these locations (in order):</p> <ol> <li>Path specified via <code>--config</code> CLI option</li> <li><code>.linkml-reference-validator.yaml</code> in current directory</li> <li><code>.linkml-reference-validator.yml</code> in current directory</li> </ol>"},{"location":"how-to/skip-unsupported-references/#examples","title":"Examples","text":""},{"location":"how-to/skip-unsupported-references/#example-1-skip-known-unsupported-types","title":"Example 1: Skip Known Unsupported Types","text":"<p>You have a knowledge base with datasets from GEO (supported) and SRA (not yet supported):</p> <pre><code># data.yaml\ndatasets:\n  - accession: geo:GSE12345\n    title: Gene expression in disease X\n  - accession: sra:PRJNA123456\n    title: Metagenome sequencing study\n</code></pre> <p>Without configuration, validation fails on the SRA reference. Add:</p> <pre><code># .linkml-reference-validator.yaml\nskip_prefixes:\n  - SRA\n</code></pre> <p>Now validation passes, skipping the SRA reference:</p> <pre><code>$ linkml-reference-validator validate data data.yaml --schema schema.yaml\n\nValidation Summary:\n  Total checks: 1\n  All validations passed!\n</code></pre>"},{"location":"how-to/skip-unsupported-references/#example-2-downgrade-all-fetch-failures-to-warnings","title":"Example 2: Downgrade All Fetch Failures to Warnings","text":"<p>For a permissive validation that reports issues without failing:</p> <pre><code># .linkml-reference-validator.yaml\nunknown_prefix_severity: WARNING\n</code></pre> <p>Output:</p> <pre><code>Validation Issues (1):\n  [WARNING] Could not fetch reference: sra:PRJNA123456\n    Location: datasets[1].title\n\nValidation Summary:\n  Total checks: 1\n  All validations passed!\n</code></pre>"},{"location":"how-to/skip-unsupported-references/#example-3-combined-configuration","title":"Example 3: Combined Configuration","text":"<p>Skip known unsupported types, warn on unexpected failures:</p> <pre><code># .linkml-reference-validator.yaml\ncache_dir: references_cache\n\nskip_prefixes:\n  - SRA\n  - MGNIFY\n  - BIOPROJECT\n\nunknown_prefix_severity: WARNING\n</code></pre> <p>This is useful when: - You know certain prefixes aren't supported yet (<code>skip_prefixes</code>) - You want to catch unexpected issues without blocking CI (<code>unknown_prefix_severity: WARNING</code>)</p>"},{"location":"how-to/skip-unsupported-references/#adding-support-for-new-reference-types","title":"Adding Support for New Reference Types","text":"<p>Instead of skipping a reference type permanently, consider adding support for it:</p> <ol> <li>YAML configuration (no code): See Adding a Custom Reference Source</li> <li>Python plugin (complex sources): See the same guide for the advanced approach</li> </ol> <p>For example, to add MGnify support via YAML:</p> <pre><code># .linkml-reference-validator-sources.yaml\nsources:\n  MGNIFY:\n    url_template: \"https://www.ebi.ac.uk/metagenomics/api/v1/studies/{id}\"\n    fields:\n      title: \"$.data.attributes.study-name\"\n      content: \"$.data.attributes.study-abstract\"\n</code></pre>"},{"location":"how-to/skip-unsupported-references/#relationship-to-custom-sources","title":"Relationship to Custom Sources","text":"Approach Use Case <code>skip_prefixes</code> Temporarily ignore references you can't validate yet <code>unknown_prefix_severity: WARNING</code> Continue validation despite fetch failures Custom source (YAML) Add support for a new API-backed reference type Custom source (Python) Add support for complex reference types"},{"location":"how-to/skip-unsupported-references/#see-also","title":"See Also","text":"<ul> <li>Adding a Custom Reference Source - Define new reference types</li> <li>CLI Reference - Command-line options</li> <li>Validating Titles - Title validation with <code>dcterms:title</code></li> </ul>"},{"location":"how-to/use-local-files-and-urls/","title":"Using Local Files and URLs as References","text":"<p>In addition to PubMed IDs and DOIs, the validator supports local files and web URLs as reference sources. This is useful when your supporting text comes from internal documentation, research notes, or web pages.</p>"},{"location":"how-to/use-local-files-and-urls/#local-file-references","title":"Local File References","text":"<p>Use the <code>file:</code> prefix to reference local files:</p> <pre><code>linkml-reference-validator validate text \\\n  \"JAK1 binds to the receptor complex\" \\\n  file:./research/jak-signaling-notes.md\n</code></pre>"},{"location":"how-to/use-local-files-and-urls/#supported-file-types","title":"Supported File Types","text":"<ul> <li>Markdown (<code>.md</code>) - Title extracted from first <code># heading</code></li> <li>Plain text (<code>.txt</code>) - Content used as-is</li> <li>HTML (<code>.html</code>) - Content preserved including HTML entities</li> </ul>"},{"location":"how-to/use-local-files-and-urls/#path-resolution","title":"Path Resolution","text":"<p>Absolute paths always work:</p> <pre><code>file:/Users/me/research/notes.md\n</code></pre> <p>Relative paths are resolved in order:</p> <ol> <li>If <code>reference_base_dir</code> is configured, paths resolve relative to it</li> <li>Otherwise, paths resolve relative to the current working directory</li> </ol> <p>Note: cached references use the resolved absolute path in the reference ID, so the cache file name reflects the full path.</p>"},{"location":"how-to/use-local-files-and-urls/#configuring-a-base-directory","title":"Configuring a Base Directory","text":"<p>Set a base directory for all relative file references:</p> <pre><code>from linkml_reference_validator.models import ReferenceValidationConfig\nfrom pathlib import Path\n\nconfig = ReferenceValidationConfig(\n    reference_base_dir=Path(\"./references\"),\n)\n</code></pre> <p>Then <code>file:notes.md</code> resolves to <code>./references/notes.md</code>.</p>"},{"location":"how-to/use-local-files-and-urls/#example-validating-against-research-notes","title":"Example: Validating Against Research Notes","text":"<p>Create a research file:</p> <pre><code># JAK-STAT Signaling Pathway\n\nJAK1 binds to the receptor complex and initiates downstream signaling.\nThis leads to STAT phosphorylation and nuclear translocation.\n</code></pre> <p>Validate:</p> <pre><code>linkml-reference-validator validate text \\\n  \"JAK1 binds to the receptor complex\" \\\n  file:./jak-signaling.md\n</code></pre>"},{"location":"how-to/use-local-files-and-urls/#url-references","title":"URL References","text":"<p>Use the <code>url:</code> prefix to reference web pages (the prefix is optional for bare HTTP/HTTPS URLs and will be normalized to <code>url:</code> internally):</p> <pre><code>linkml-reference-validator validate text \\\n  \"Climate change affects biodiversity\" \\\n  url:https://example.org/climate-report.html\n</code></pre>"},{"location":"how-to/use-local-files-and-urls/#caching","title":"Caching","text":"<p>URLs are cached the same way as PMID and DOI references:</p> <ul> <li>First fetch downloads and caches the content</li> <li>Subsequent validations use the cached version</li> <li>Use <code>linkml-reference-validator cache reference url:https://... --force</code> to re-fetch</li> </ul>"},{"location":"how-to/use-local-files-and-urls/#title-extraction","title":"Title Extraction","text":"<p>For HTML pages, the title is extracted from the <code>&lt;title&gt;</code> tag. For other content types, the URL itself is used as the title.</p>"},{"location":"how-to/use-local-files-and-urls/#example-validating-against-a-web-page","title":"Example: Validating Against a Web Page","text":"<pre><code># First validation fetches and caches\nlinkml-reference-validator validate text \\\n  \"The quick brown fox jumps over the lazy dog\" \\\n  url:https://example.com/pangram-examples.html\n\n# Subsequent validations use cache\nlinkml-reference-validator validate text \\\n  \"A quick brown fox\" \\\n  url:https://example.com/pangram-examples.html\n</code></pre>"},{"location":"how-to/use-local-files-and-urls/#using-in-data-files","title":"Using in Data Files","text":"<p>Both file and URL references work in LinkML data files:</p> <pre><code># data.yaml\n- id: local-evidence\n  supporting_text: JAK1 binds to the receptor complex\n  reference: file:./research/jak-notes.md\n\n- id: web-evidence\n  supporting_text: Climate impacts are accelerating\n  reference: url:https://example.org/climate-report.html\n</code></pre>"},{"location":"how-to/use-local-files-and-urls/#reference-type-summary","title":"Reference Type Summary","text":"Prefix Example Source <code>PMID:</code> <code>PMID:16888623</code> PubMed via NCBI Entrez <code>DOI:</code> <code>DOI:10.1038/nature12373</code> Crossref API <code>file:</code> <code>file:./notes.md</code> Local filesystem <code>url:</code> <code>url:https://example.com</code> Web (HTTP/HTTPS)"},{"location":"how-to/use-local-files-and-urls/#best-practices","title":"Best Practices","text":""},{"location":"how-to/use-local-files-and-urls/#for-local-files","title":"For Local Files","text":"<ul> <li>Keep reference files in a dedicated directory</li> <li>Use <code>reference_base_dir</code> for consistent path resolution</li> <li>Use markdown for structured content with clear headings</li> </ul>"},{"location":"how-to/use-local-files-and-urls/#for-urls","title":"For URLs","text":"<ul> <li>Prefer stable URLs (avoid query parameters that change)</li> <li>Be aware that web content may change (cache helps with reproducibility)</li> <li>Consider downloading important pages as local files for long-term stability</li> </ul>"},{"location":"how-to/use-local-files-and-urls/#limitations","title":"Limitations","text":"<ul> <li>PDF files: Not yet supported (planned for future)</li> <li>Authentication: URLs requiring login are not supported</li> <li>Dynamic content: JavaScript-rendered pages may not work</li> </ul>"},{"location":"how-to/validate-clinical-trials/","title":"Validating ClinicalTrials.gov References","text":"<p>This guide shows how to validate supporting text against clinical trial records from ClinicalTrials.gov.</p>"},{"location":"how-to/validate-clinical-trials/#overview","title":"Overview","text":"<p>The ClinicalTrials.gov source fetches trial data from the ClinicalTrials.gov API v2. It extracts:</p> <ul> <li>Title: Official title (falls back to brief title)</li> <li>Content: Brief summary (falls back to detailed description)</li> <li>Metadata: Trial status and lead sponsor</li> </ul> <p>The source uses the bioregistry standard prefix <code>clinicaltrials</code> with identifiers following the pattern <code>NCT</code> followed by 8 digits (e.g., <code>NCT00000001</code>).</p>"},{"location":"how-to/validate-clinical-trials/#basic-usage","title":"Basic Usage","text":"<p>Validate text against a clinical trial using its NCT identifier:</p> <pre><code>linkml-reference-validator validate text \\\n  \"A randomized controlled trial investigating...\" \\\n  clinicaltrials:NCT00000001\n</code></pre>"},{"location":"how-to/validate-clinical-trials/#accepted-identifier-formats","title":"Accepted Identifier Formats","text":"<p>You can use the bioregistry standard prefix or bare NCT identifiers:</p> <pre><code>clinicaltrials:NCT00000001\nclinicaltrials:NCT12345678\nNCT00000001\nNCT12345678\n</code></pre> <p>The prefix is case-insensitive:</p> <pre><code>clinicaltrials:NCT00000001\nCLINICALTRIALS:NCT00000001\n</code></pre>"},{"location":"how-to/validate-clinical-trials/#prefix-aliases-and-normalization","title":"Prefix Aliases and Normalization","text":"<p>If your data uses alternate prefix styles (e.g., the legacy <code>NCT:</code> prefix), configure normalization in <code>.linkml-reference-validator.yaml</code>:</p> <pre><code>validation:\n  reference_prefix_map:\n    NCT: clinicaltrials\n    nct: clinicaltrials\n    ct: clinicaltrials\n    ClinicalTrials: clinicaltrials\n</code></pre> <p>Or programmatically:</p> <pre><code>from linkml_reference_validator.models import ReferenceValidationConfig\n\nconfig = ReferenceValidationConfig(\n    reference_prefix_map={\n        \"NCT\": \"clinicaltrials\",\n        \"ct\": \"clinicaltrials\",\n    }\n)\n</code></pre>"},{"location":"how-to/validate-clinical-trials/#pre-caching-clinical-trial-records","title":"Pre-caching Clinical Trial Records","text":"<p>To cache trial data for offline validation or faster repeated access:</p> <pre><code>linkml-reference-validator cache reference clinicaltrials:NCT00000001\n</code></pre> <p>Cached references are stored in <code>references_cache/</code> as markdown files with YAML frontmatter containing metadata like trial status and sponsor.</p>"},{"location":"how-to/validate-clinical-trials/#rate-limiting","title":"Rate Limiting","text":"<p>The ClinicalTrials.gov API has rate limits. The default <code>rate_limit_delay</code> of 0.5 seconds between requests should be sufficient for most use cases:</p> <pre><code>from linkml_reference_validator.models import ReferenceValidationConfig\n\nconfig = ReferenceValidationConfig(\n    rate_limit_delay=0.5,  # default\n)\n</code></pre>"},{"location":"how-to/validate-clinical-trials/#content-availability","title":"Content Availability","text":"<p>Not all trials have detailed descriptions. If only a brief summary is available, that will be used for validation. Trials without any description will return <code>content_type: unavailable</code>.</p>"},{"location":"how-to/validate-clinical-trials/#example-validating-trial-descriptions","title":"Example: Validating Trial Descriptions","text":"<pre><code>from linkml_reference_validator.etl.sources import ClinicalTrialsSource\nfrom linkml_reference_validator.models import ReferenceValidationConfig\n\nconfig = ReferenceValidationConfig()\nsource = ClinicalTrialsSource()\n\n# Fetch trial content\ncontent = source.fetch(\"NCT00000001\", config)\n\nif content:\n    print(f\"Reference ID: {content.reference_id}\")  # clinicaltrials:NCT00000001\n    print(f\"Title: {content.title}\")\n    print(f\"Summary: {content.content}\")\n    print(f\"Status: {content.metadata.get('status')}\")\n    print(f\"Sponsor: {content.metadata.get('sponsor')}\")\n</code></pre>"},{"location":"how-to/validate-clinical-trials/#bioregistry-standard","title":"Bioregistry Standard","text":"<p>This source follows the bioregistry standard for ClinicalTrials.gov identifiers:</p> <ul> <li>Prefix: <code>clinicaltrials</code></li> <li>Pattern: <code>^NCT\\d{8}$</code></li> <li>Example CURIE: <code>clinicaltrials:NCT00222573</code></li> </ul> <p>Alternative prefixes recognized by bioregistry include <code>clinicaltrial</code>, <code>NCT</code>, and <code>ctgov</code>. Use the <code>reference_prefix_map</code> configuration to normalize these to the standard prefix.</p>"},{"location":"how-to/validate-clinical-trials/#see-also","title":"See Also","text":"<ul> <li>Validating Entrez Accessions - Similar pattern for NCBI databases</li> <li>Adding a New Reference Source - How the plugin system works</li> <li>Quickstart - Getting started guide</li> <li>CLI Reference - Complete command documentation</li> </ul>"},{"location":"how-to/validate-dois/","title":"Validating Text Against DOIs","text":"<p>This guide shows how to validate supporting text against publications using Digital Object Identifiers (DOIs).</p>"},{"location":"how-to/validate-dois/#overview","title":"Overview","text":"<p>DOIs are persistent identifiers for digital objects, commonly used for journal articles and data repositories. The validator fetches publication metadata from:</p> <ol> <li>Crossref API - Primary source for journal articles</li> <li>DataCite API - Fallback for repository DOIs (Zenodo, Figshare, Dryad, OSTI)</li> </ol> <p>This dual-source approach ensures broad coverage across both scholarly publications and data repositories.</p>"},{"location":"how-to/validate-dois/#basic-usage","title":"Basic Usage","text":""},{"location":"how-to/validate-dois/#validate-a-single-quote","title":"Validate a Single Quote","text":"<pre><code>linkml-reference-validator validate text \\\n  \"Nanometre-scale thermometry\" \\\n  DOI:10.1038/nature12373\n</code></pre> <p>Output:</p> <pre><code>Validating text against DOI:10.1038/nature12373...\n  Text: Nanometre-scale thermometry\n\nResult:\n  Valid: True\n  Message: Supporting text validated successfully in DOI:10.1038/nature12373\n</code></pre>"},{"location":"how-to/validate-dois/#doi-format","title":"DOI Format","text":"<p>DOIs should be prefixed with <code>DOI:</code>:</p> <pre><code>DOI:10.1038/nature12373\nDOI:10.1126/science.1234567\nDOI:10.1016/j.cell.2023.01.001\n</code></pre> <p>The DOI itself follows the standard format: <code>10.prefix/suffix</code></p>"},{"location":"how-to/validate-dois/#supported-repository-dois","title":"Supported Repository DOIs","text":"<p>The validator supports DOIs from data repositories via the DataCite API:</p> Repository DOI Prefix Example Zenodo <code>10.5281/zenodo.*</code> <code>DOI:10.5281/zenodo.7961621</code> Figshare <code>10.6084/m9.figshare.*</code> <code>DOI:10.6084/m9.figshare.123456</code> Dryad <code>10.5061/dryad.*</code> <code>DOI:10.5061/dryad.abc123</code> OSTI <code>10.2172/*</code> <code>DOI:10.2172/1234567</code>"},{"location":"how-to/validate-dois/#looking-up-repository-dois","title":"Looking Up Repository DOIs","text":"<pre><code>linkml-reference-validator lookup DOI:10.5281/zenodo.7961621\n</code></pre> <p>For Zenodo DOIs, the output includes supplementary file metadata:</p> <pre><code>Reference: DOI:10.5281/zenodo.7961621\nTitle: Gene Ontology Curators AI Workshop\nAuthors: Dickinson R, Carbon S, Mungall CJ\n...\nContent type: abstract_only\n\n--- Supplementary Files (3) ---\n  - Dickinson_Varenna2022.pdf (1,975,995 bytes)\n  - workshop_slides.pptx (2,345,678 bytes)\n  - data_analysis.xlsx (123,456 bytes)\n</code></pre>"},{"location":"how-to/validate-dois/#downloading-supplementary-files","title":"Downloading Supplementary Files","text":"<p>By default, only metadata about supplementary files is captured. To download the actual files:</p> <pre><code>linkml-reference-validator lookup -D DOI:10.5281/zenodo.7961621\n</code></pre> <p>Downloaded files are stored in:</p> <pre><code>references_cache/\n  files/\n    DOI_10.5281_zenodo.7961621/\n      Dickinson_Varenna2022.pdf\n      workshop_slides.pptx\n      data_analysis.xlsx\n</code></pre>"},{"location":"how-to/validate-dois/#publisher-dois-vs-repository-dois","title":"Publisher DOIs vs Repository DOIs","text":"<p>Important: Supplementary file support only works for repository DOIs (Zenodo, Figshare, Dryad), not for publisher DOIs (Elsevier, Springer, Nature, etc.).</p> DOI Type Example Supplementary Files Repository (Zenodo) <code>10.5281/zenodo.7961621</code> \u2705 File metadata + download Repository (Figshare) <code>10.6084/m9.figshare.123456</code> \u2705 File metadata + download Publisher (Elsevier) <code>10.1016/j.neuron.2011.05.021</code> \u274c Not available Publisher (Nature) <code>10.1038/nature12373</code> \u274c Not available <p>Why the difference?</p> <ul> <li>Repository APIs (Zenodo, Figshare) are designed for data sharing and provide open, documented file APIs</li> <li>Publisher APIs (Elsevier, Springer) require paid institutional access or text-mining agreements</li> <li>Even when articles are in PMC, supplementary files are often not available via the OA API</li> </ul> <p>Workarounds for publisher supplementary files:</p> <ol> <li>Manual download: Download supplementary files from the publisher website and use <code>file:</code> references</li> <li>Data repository: Check if the authors deposited data separately in Zenodo/Figshare/Dryad</li> <li>PubMed Central: For some OA articles, supplementary files may be available via PMC</li> </ol>"},{"location":"how-to/validate-dois/#pre-caching-dois","title":"Pre-caching DOIs","text":"<p>For offline validation or to speed up repeated validations:</p> <pre><code>linkml-reference-validator cache reference DOI:10.1038/nature12373\n</code></pre> <p>Output:</p> <pre><code>Fetching DOI:10.1038/nature12373...\nSuccessfully cached DOI:10.1038/nature12373\n  Title: Nanometre-scale thermometry in a living cell\n  Authors: G. Kucsko, P. C. Maurer, N. Y. Yao\n  Content type: abstract_only\n  Content length: 1234 characters\n</code></pre> <p>Cached references are stored in <code>references_cache/</code> as markdown files with YAML frontmatter.</p>"},{"location":"how-to/validate-dois/#using-dois-in-data-files","title":"Using DOIs in Data Files","text":"<p>DOIs work the same as PMIDs in LinkML data files:</p> <p>schema.yaml:</p> <pre><code>id: https://example.org/my-schema\nname: my-schema\n\nprefixes:\n  linkml: https://w3id.org/linkml/\n\nclasses:\n  Statement:\n    attributes:\n      id:\n        identifier: true\n      supporting_text:\n        slot_uri: linkml:excerpt\n      reference:\n        slot_uri: linkml:authoritative_reference\n</code></pre> <p>data.yaml:</p> <pre><code>- id: stmt1\n  supporting_text: Nanometre-scale thermometry\n  reference: DOI:10.1038/nature12373\n- id: stmt2\n  supporting_text: MUC1 oncoprotein blocks nuclear targeting\n  reference: PMID:16888623\n</code></pre> <p>Validate:</p> <pre><code>linkml-reference-validator validate data \\\n  data.yaml \\\n  --schema schema.yaml \\\n  --target-class Statement\n</code></pre> <p>You can mix DOIs and PMIDs in the same data file.</p>"},{"location":"how-to/validate-dois/#repairing-doi-references","title":"Repairing DOI References","text":"<p>The repair command also works with DOIs:</p> <pre><code>linkml-reference-validator repair text \\\n  \"Nanometre scale thermometry\" \\\n  DOI:10.1038/nature12373\n</code></pre>"},{"location":"how-to/validate-dois/#doi-vs-pmid-when-to-use-each","title":"DOI vs PMID: When to Use Each","text":"Feature PMID DOI Source NCBI PubMed Crossref + DataCite Coverage Biomedical literature All scholarly content + data repos Full text Via PMC when available Metadata only Abstract Usually available Depends on publisher/repo Keywords MeSH terms Subjects (if available) Supplementary files No Yes (Zenodo, etc.) <p>Use PMID when: - Working with biomedical/life science literature - Full text access is important - The article is indexed in PubMed - You need MeSH term keywords</p> <p>Use DOI when: - The article is not in PubMed - Working with non-biomedical journals - Working with data repositories (Zenodo, Figshare, Dryad) - You need supplementary file metadata</p>"},{"location":"how-to/validate-dois/#content-availability","title":"Content Availability","text":"<p>Unlike PMIDs which often provide abstracts, DOI metadata from Crossref may have limited content:</p> <ul> <li>Title: Always available</li> <li>Authors: Usually available</li> <li>Abstract: Depends on publisher policy</li> <li>Full text: Not available via Crossref</li> </ul> <p>If the abstract is not available, validation will be limited to matching against the title and other metadata.</p>"},{"location":"how-to/validate-dois/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/validate-dois/#content-type-unavailable","title":"\"Content type: unavailable\"","text":"<p>This means Crossref returned metadata but no abstract. The DOI was fetched successfully, but validation may fail if your text doesn't match the title.</p> <p>Solution: Consider using the PMID if the article is in PubMed.</p>"},{"location":"how-to/validate-dois/#failed-to-fetch-doi","title":"\"Failed to fetch DOI\"","text":"<p>The DOI may be invalid or both APIs (Crossref and DataCite) may have failed.</p> <p>How DOI resolution works: 1. First, the validator tries Crossref API 2. If Crossref returns 404, it falls back to DataCite API 3. If both fail, the error is reported</p> <p>Check: 1. Verify the DOI format (should be <code>10.prefix/suffix</code>) 2. Test the DOI at https://doi.org/YOUR_DOI 3. Try again later if APIs are rate-limiting 4. For repository DOIs (Zenodo, etc.), ensure the record is public</p>"},{"location":"how-to/validate-dois/#rate-limiting","title":"Rate Limiting","text":"<p>The validator automatically respects Crossref rate limits. For bulk operations, consider:</p> <ol> <li>Pre-caching references before validation</li> <li>Using a polite pool (add your email in config for higher limits)</li> </ol>"},{"location":"how-to/validate-dois/#see-also","title":"See Also","text":"<ul> <li>Quickstart - Getting started with validation</li> <li>CLI Reference - Complete command documentation</li> <li>Validating OBO Files - Working with ontology files</li> </ul>"},{"location":"how-to/validate-entrez/","title":"Validating Entrez Accessions","text":"<p>This guide shows how to validate supporting text against NCBI Entrez records for GEO, BioProject, and BioSample.</p>"},{"location":"how-to/validate-entrez/#overview","title":"Overview","text":"<p>These sources use the NCBI Entrez E-utilities:</p> <ul> <li>GEO (GSE/GDS): Uses <code>esearch</code> to convert accessions to UIDs, then <code>esummary</code> from the <code>gds</code> database</li> <li>BioProject (PRJNA/PRJEB/PRJDB): Uses <code>esummary</code> from the <code>bioproject</code> database</li> <li>BioSample (SAMN/SAME/SAMD): Uses <code>esummary</code> from the <code>biosample</code> database</li> </ul> <p>The validator uses the returned summary/description fields as the content for matching.</p>"},{"location":"how-to/validate-entrez/#basic-usage","title":"Basic Usage","text":""},{"location":"how-to/validate-entrez/#geo-gse-or-gds","title":"GEO (GSE or GDS)","text":"<pre><code>linkml-reference-validator validate text \\\n  \"RNA-seq analysis of cardiac tissue\" \\\n  GEO:GSE12345\n</code></pre>"},{"location":"how-to/validate-entrez/#validating-with-title-check","title":"Validating with Title Check","text":"<p>You can also validate that the reference title matches your expected title:</p> <pre><code># This will validate both the excerpt AND the title\nlinkml-reference-validator validate text \\\n  \"Airway epithelial brushings\" \\\n  GEO:GSE67472 \\\n  --title \"Airway epithelial gene expression in asthma versus healthy controls\"\n</code></pre> <p>If the title doesn't match, validation will fail with a \"title mismatch\" error.</p>"},{"location":"how-to/validate-entrez/#bioproject","title":"BioProject","text":"<pre><code>linkml-reference-validator validate text \\\n  \"Whole genome sequencing project for strain X\" \\\n  BioProject:PRJNA12345\n</code></pre>"},{"location":"how-to/validate-entrez/#biosample","title":"BioSample","text":"<pre><code>linkml-reference-validator validate text \\\n  \"Human liver biopsy sample description\" \\\n  BioSample:SAMN12345678\n</code></pre>"},{"location":"how-to/validate-entrez/#accepted-identifier-formats","title":"Accepted Identifier Formats","text":"<p>You can use either prefixed or bare accessions:</p> <pre><code>GEO:GSE12345\nGDS12345\nBioProject:PRJNA12345\nPRJEB12345\nBioSample:SAMN12345678\nSAME1234567\n</code></pre>"},{"location":"how-to/validate-entrez/#prefix-aliases-and-normalization","title":"Prefix Aliases and Normalization","text":"<p>Prefixes are case-insensitive and can be normalized with a configuration map. This is useful when data uses alternate prefix styles such as <code>geo:</code> or <code>NCBIGeo:</code>.</p> <p>Create <code>.linkml-reference-validator.yaml</code> with a <code>validation</code> section:</p> <pre><code>validation:\n  reference_prefix_map:\n    geo: GEO\n    NCBIGeo: GEO\n    NCBIBioProject: BIOPROJECT\n    NCBIBioSample: BIOSAMPLE\n</code></pre> <p>You can also configure this programmatically:</p> <pre><code>from linkml_reference_validator.models import ReferenceValidationConfig\n\nconfig = ReferenceValidationConfig(\n    reference_prefix_map={\"geo\": \"GEO\", \"NCBIGeo\": \"GEO\"}\n)\n</code></pre> <p>Pass the config file to CLI commands with <code>--config .linkml-reference-validator.yaml</code>.</p>"},{"location":"how-to/validate-entrez/#pre-caching-entrez-records","title":"Pre-caching Entrez Records","text":"<p>For offline validation or to speed up repeated validations:</p> <pre><code>linkml-reference-validator cache reference GEO:GSE12345\nlinkml-reference-validator cache reference BioProject:PRJNA12345\nlinkml-reference-validator cache reference BioSample:SAMN12345678\n</code></pre> <p>Cached references are stored in <code>references_cache/</code> as markdown files with YAML frontmatter.</p>"},{"location":"how-to/validate-entrez/#rate-limiting-and-email","title":"Rate Limiting and Email","text":"<p>NCBI requires a valid contact email for Entrez API usage. Configure it in your settings:</p> <pre><code>from linkml_reference_validator.models import ReferenceValidationConfig\n\nconfig = ReferenceValidationConfig(\n    email=\"you@example.org\",\n    rate_limit_delay=0.5,\n)\n</code></pre>"},{"location":"how-to/validate-entrez/#content-availability","title":"Content Availability","text":"<p>Entrez summaries vary by record. If a summary field is missing, the validator will return <code>content_type: unavailable</code> and matching may fail.</p>"},{"location":"how-to/validate-entrez/#validation-failure-scenarios","title":"Validation Failure Scenarios","text":"<p>The validator catches several types of errors:</p>"},{"location":"how-to/validate-entrez/#excerpt-not-found","title":"Excerpt Not Found","text":"<p>When the quoted text is not in the reference content:</p> <pre><code>$ linkml-reference-validator validate text \\\n    \"text that is not in the dataset\" \\\n    GEO:GSE67472\n\nResult:\n  Valid: False\n  Message: Text part not found as substring: 'text that is not in the dataset'\n</code></pre>"},{"location":"how-to/validate-entrez/#title-mismatch","title":"Title Mismatch","text":"<p>When the expected title doesn't match the actual reference title:</p> <pre><code>$ linkml-reference-validator validate text \\\n    \"Airway epithelial brushings\" \\\n    GEO:GSE67472 \\\n    --title \"Wrong Title Here\"\n\nResult:\n  Valid: False\n  Message: Title mismatch for GEO:GSE67472\n    Expected: \"Wrong Title Here\"\n    Actual: \"Airway epithelial gene expression in asthma versus healthy controls\"\n</code></pre>"},{"location":"how-to/validate-entrez/#reference-not-found","title":"Reference Not Found","text":"<p>When the accession doesn't exist:</p> <pre><code>$ linkml-reference-validator validate text \\\n    \"Some text\" \\\n    GEO:GSE99999999999\n\nResult:\n  Valid: False\n  Message: Could not fetch reference GEO:GSE99999999999\n</code></pre>"},{"location":"how-to/validate-entrez/#configuration-file","title":"Configuration File","text":"<p>Create <code>.linkml-reference-validator.yaml</code> in your project root for persistent configuration:</p> <pre><code>validation:\n  # NCBI requires a valid email for Entrez API usage\n  email: you@example.org\n\n  # Rate limiting (seconds between API calls)\n  rate_limit_delay: 0.5\n\n  # Cache directory for offline use\n  cache_dir: references_cache\n\n  # Map alternate prefixes to canonical forms\n  reference_prefix_map:\n    geo: GEO\n    NCBIGeo: GEO\n    NCBIBioProject: BIOPROJECT\n    NCBIBioSample: BIOSAMPLE\n</code></pre> <p>Pass the config to CLI commands:</p> <pre><code>linkml-reference-validator validate text \\\n  \"Some text\" \\\n  GEO:GSE67472 \\\n  --config .linkml-reference-validator.yaml\n</code></pre>"},{"location":"how-to/validate-entrez/#how-geo-accession-to-uid-conversion-works","title":"How GEO Accession-to-UID Conversion Works","text":"<p>The GDS Entrez database requires numeric UIDs, not accession numbers like GSE67472. The GEOSource automatically handles this conversion:</p> <ol> <li> <p>esearch: Searches for the accession and returns the numeric UID    <code>esearch(db=\"gds\", term=\"GSE67472[Accession]\") \u2192 \"200067472\"</code></p> </li> <li> <p>esummary: Uses the UID to fetch the dataset metadata    <code>esummary(db=\"gds\", id=\"200067472\") \u2192 {title, summary, ...}</code></p> </li> </ol> <p>This conversion happens transparently - you just use the GSE/GDS accession.</p>"},{"location":"how-to/validate-entrez/#see-also","title":"See Also","text":"<ul> <li>Adding a New Reference Source</li> <li>Validating Titles</li> <li>Quickstart</li> <li>CLI Reference</li> </ul>"},{"location":"how-to/validate-obo-files/","title":"Validating OBO Format Files","text":"<p>This guide shows how to validate supporting text in OBO format ontology files using the <code>validate text-file</code> command.</p>"},{"location":"how-to/validate-obo-files/#overview","title":"Overview","text":"<p>OBO format ontologies may include axiom annotations that contain supporting text from publications. For example:</p> <pre><code>[Term]\nid: GO:0043263\nname: cellulosome\ndef: \"An extracellular multi-enzyme complex...\" [PMID:11601609] {ex:supporting_text=\"a unique extracellular multi-enzyme complex, called cellulosome[PMID:11601609]\"}\n</code></pre> <p>The <code>validate text-file</code> command can extract these supporting text annotations using regular expressions and validate them against the referenced publications.</p>"},{"location":"how-to/validate-obo-files/#basic-usage","title":"Basic Usage","text":""},{"location":"how-to/validate-obo-files/#command-structure","title":"Command Structure","text":"<pre><code>linkml-reference-validator validate text-file &lt;file-path&gt; \\\n  --regex &lt;pattern&gt; \\\n  [--text-group &lt;number&gt;] \\\n  [--ref-group &lt;number&gt;] \\\n  [--summary]\n</code></pre>"},{"location":"how-to/validate-obo-files/#example-validating-obo-axiom-annotations","title":"Example: Validating OBO Axiom Annotations","text":"<p>For OBO files with <code>ex:supporting_text</code> annotations:</p> <pre><code>linkml-reference-validator validate text-file my_ontology.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --text-group 1 \\\n  --ref-group 2\n</code></pre> <p>Explanation: - <code>--regex</code>: Regular expression pattern with two capture groups   - Group 1: <code>([^\"]*)</code> - captures the supporting text (everything before <code>[</code>)   - Group 2: <code>(\\S+:\\S+)</code> - captures the reference ID (e.g., <code>PMID:11601609</code>) - <code>--text-group 1</code>: First capture group contains the supporting text - <code>--ref-group 2</code>: Second capture group contains the reference ID</p>"},{"location":"how-to/validate-obo-files/#example-output","title":"Example Output","text":"<pre><code>Extracting text from my_ontology.obo\n  Regex pattern: ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"\n  Text group: 1, Reference group: 2\n  Cache directory: references_cache\n\nFound 15 match(es) to validate\n\nLine 8: def: \"...\" [PMID:11601609] {ex:supporting_text=\"a unique extracel...\n  \u2713 VALID: Supporting text validated successfully\n\nLine 23: def: \"...\" [PMID:23456789] {ex:supporting_text=\"protein complex fo...\n  \u2717 INVALID: Supporting text not found in reference\n\n============================================================\nValidation Summary:\n  Total validations: 15\n  Valid: 13\n  Invalid: 2\n  Errors: 2\n\n\u2717 Some validations failed\n</code></pre>"},{"location":"how-to/validate-obo-files/#advanced-usage","title":"Advanced Usage","text":""},{"location":"how-to/validate-obo-files/#summary-mode","title":"Summary Mode","text":"<p>To see only the summary statistics without individual line results:</p> <pre><code>linkml-reference-validator validate text-file my_ontology.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --summary\n</code></pre>"},{"location":"how-to/validate-obo-files/#verbose-mode","title":"Verbose Mode","text":"<p>To see detailed matching information:</p> <pre><code>linkml-reference-validator validate text-file my_ontology.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --verbose\n</code></pre>"},{"location":"how-to/validate-obo-files/#custom-cache-directory","title":"Custom Cache Directory","text":"<p>To use a specific cache directory for downloaded references:</p> <pre><code>linkml-reference-validator validate text-file my_ontology.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --cache-dir /path/to/cache\n</code></pre>"},{"location":"how-to/validate-obo-files/#regex-pattern-guide","title":"Regex Pattern Guide","text":"<p>The regex pattern must have at least two capture groups: 1. One for the supporting text 2. One for the reference ID</p>"},{"location":"how-to/validate-obo-files/#common-patterns","title":"Common Patterns","text":"<p>OBO axiom annotations:</p> <pre><code>ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"\n</code></pre> <p>Different annotation property:</p> <pre><code>my_prop:text=\"([^\"]*)\" my_prop:ref=(\\S+)\n</code></pre> <p>Custom format:</p> <pre><code>evidence\\{text:([^,]+),ref:([^}]+)\\}\n</code></pre>"},{"location":"how-to/validate-obo-files/#capture-group-specification","title":"Capture Group Specification","text":"<p>By default: - <code>--text-group 1</code> (first capture group is supporting text) - <code>--ref-group 2</code> (second capture group is reference ID)</p> <p>You can change these if your pattern has groups in a different order:</p> <pre><code># If reference comes before text in your pattern\nlinkml-reference-validator validate text-file file.obo \\\n  --regex 'ref=(\\S+) text=\"([^\"]+)\"' \\\n  --text-group 2 \\\n  --ref-group 1\n</code></pre>"},{"location":"how-to/validate-obo-files/#understanding-results","title":"Understanding Results","text":""},{"location":"how-to/validate-obo-files/#valid-results","title":"Valid Results (\u2713)","text":"<p>The supporting text was found in the reference content (abstract or full text) using substring matching.</p>"},{"location":"how-to/validate-obo-files/#invalid-results","title":"Invalid Results (\u2717)","text":"<p>The supporting text was not found. This could mean: - The text is a hallucination or paraphrase - The text uses different wording than the source - The reference ID is incorrect - The full text is not available (only abstract was checked)</p>"},{"location":"how-to/validate-obo-files/#editorial-conventions","title":"Editorial Conventions","text":"<p>The validator supports editorial conventions: - <code>[...]</code> - Editorial insertions (ignored during matching) - <code>...</code> - Omitted text (matches any text)</p> <p>Example:</p> <pre><code>Supporting text: \"protein [X] functions ... in cells\"\nMatches: \"protein ABC functions in regulation of cell growth in cells\"\n</code></pre>"},{"location":"how-to/validate-obo-files/#best-practices","title":"Best Practices","text":"<ol> <li>Start with a small test file to verify your regex pattern works correctly</li> <li>Use verbose mode initially to understand what's being matched</li> <li>Cache references locally to avoid repeated API calls during development</li> <li>Check the extraction first - if no matches are found, your regex may be incorrect</li> <li>Be specific with your regex to avoid false matches</li> </ol>"},{"location":"how-to/validate-obo-files/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/validate-obo-files/#no-matches-found","title":"No matches found","text":"<ul> <li>Verify your regex pattern matches the actual file format</li> <li>Use a regex tester to check your pattern against sample lines</li> <li>Check that capture groups are correctly numbered</li> </ul>"},{"location":"how-to/validate-obo-files/#all-validations-fail","title":"All validations fail","text":"<ul> <li>Check that reference IDs are correct (e.g., <code>PMID:12345</code>)</li> <li>Verify supporting text is actually from the reference</li> <li>Use <code>--verbose</code> to see what text is being searched</li> </ul>"},{"location":"how-to/validate-obo-files/#rate-limiting","title":"Rate limiting","text":"<ul> <li>Use <code>--cache-dir</code> to cache downloaded references</li> <li>The validator respects rate limits automatically (0.5s delay between requests)</li> </ul>"},{"location":"how-to/validate-obo-files/#see-also","title":"See Also","text":"<ul> <li>How It Works - Understanding the validation process</li> <li>Editorial Conventions - Supported text patterns</li> <li>CLI Reference - Complete CLI documentation</li> </ul>"},{"location":"how-to/validate-titles/","title":"Validating Reference Titles","text":"<p>This guide explains how to validate that reference titles in your data match the actual titles from the source publications.</p>"},{"location":"how-to/validate-titles/#overview","title":"Overview","text":"<p>Title validation ensures that when you cite a reference with a title, that title matches what the publication actually has. Unlike excerpt validation (which uses substring matching), title validation uses exact matching after normalization.</p>"},{"location":"how-to/validate-titles/#when-to-use-title-validation","title":"When to Use Title Validation","text":"<p>Title validation is useful when:</p> <ul> <li>Your data includes reference titles that should match the source</li> <li>You want to catch typos or outdated titles</li> <li>You need to verify metadata accuracy in curated datasets</li> </ul>"},{"location":"how-to/validate-titles/#schema-setup","title":"Schema Setup","text":"<p>Mark title fields in your LinkML schema using <code>dcterms:title</code>:</p>"},{"location":"how-to/validate-titles/#using-implements","title":"Using <code>implements</code>","text":"<pre><code>id: https://example.org/my-schema\nname: my-schema\n\nprefixes:\n  linkml: https://w3id.org/linkml/\n  dcterms: http://purl.org/dc/terms/\n\nclasses:\n  Evidence:\n    attributes:\n      reference:\n        implements:\n          - linkml:authoritative_reference\n      reference_title:\n        implements:\n          - dcterms:title\n      supporting_text:\n        implements:\n          - linkml:excerpt\n</code></pre>"},{"location":"how-to/validate-titles/#using-slot_uri","title":"Using <code>slot_uri</code>","text":"<pre><code>classes:\n  Evidence:\n    attributes:\n      reference:\n        slot_uri: linkml:authoritative_reference\n      title:\n        slot_uri: dcterms:title\n      supporting_text:\n        slot_uri: linkml:excerpt\n</code></pre>"},{"location":"how-to/validate-titles/#example-data","title":"Example Data","text":"<p>data.yaml:</p> <pre><code>- reference: PMID:16888623\n  reference_title: \"MUC1 oncoprotein blocks nuclear targeting of c-Abl\"\n  supporting_text: \"MUC1 oncoprotein blocks nuclear targeting\"\n</code></pre> <p>Validate:</p> <pre><code>linkml-reference-validator validate data \\\n  data.yaml \\\n  --schema schema.yaml \\\n  --target-class Evidence\n</code></pre>"},{"location":"how-to/validate-titles/#what-gets-normalized","title":"What Gets Normalized","text":"<p>Title matching allows for minor orthographic variations:</p> Variation Example Case <code>\"JAK1 Protein\"</code> matches <code>\"jak1 protein\"</code> Whitespace <code>\"Cell  Signaling\"</code> matches <code>\"Cell Signaling\"</code> Punctuation <code>\"T-Cell Receptor\"</code> matches <code>\"T Cell Receptor\"</code> Greek letters <code>\"\u03b1-catenin\"</code> matches <code>\"alpha-catenin\"</code> Trailing periods <code>\"Study Title.\"</code> matches <code>\"Study Title\"</code>"},{"location":"how-to/validate-titles/#title-only-validation","title":"Title-Only Validation","text":"<p>You can validate titles without excerpts. If your data has reference and title fields but no excerpt field, the validator will validate the title alone:</p> <pre><code>classes:\n  Reference:\n    attributes:\n      id:\n        implements:\n          - linkml:authoritative_reference\n      title:\n        implements:\n          - dcterms:title\n</code></pre> <pre><code>- id: PMID:16888623\n  title: \"MUC1 oncoprotein blocks nuclear targeting of c-Abl\"\n</code></pre>"},{"location":"how-to/validate-titles/#combined-validation","title":"Combined Validation","text":"<p>When both title and excerpt fields are present, both are validated together:</p> <ol> <li>The excerpt is checked for substring match in the reference content</li> <li>The title is checked for exact match (after normalization) against the reference title</li> </ol> <p>If either fails, validation fails with a specific error message.</p>"},{"location":"how-to/validate-titles/#error-messages","title":"Error Messages","text":""},{"location":"how-to/validate-titles/#title-mismatch","title":"Title Mismatch","text":"<pre><code>Title mismatch for PMID:16888623: expected 'Wrong Title' but got 'MUC1 oncoprotein blocks nuclear targeting of c-Abl'\n</code></pre>"},{"location":"how-to/validate-titles/#reference-has-no-title","title":"Reference Has No Title","text":"<pre><code>Reference PMID:99999999 has no title to validate against\n</code></pre>"},{"location":"how-to/validate-titles/#differences-from-excerpt-validation","title":"Differences from Excerpt Validation","text":"Aspect Title Validation Excerpt Validation Matching Exact (after normalization) Substring Partial matches Not allowed Allowed with <code>...</code> Editorial notes Not supported <code>[brackets]</code> removed Use case Metadata accuracy Quote verification"},{"location":"how-to/validate-titles/#best-practices","title":"Best Practices","text":"<ol> <li>Use exact titles: Copy the title exactly from the source</li> <li>Don't abbreviate: Title must match completely</li> <li>Check special characters: Greek letters, subscripts, etc.</li> <li>Verify after fetching: The cached reference shows the actual title</li> </ol>"},{"location":"how-to/validate-urls/","title":"Validating URL References","text":"<p>This guide explains how to validate references that use URLs instead of traditional identifiers like PMIDs or DOIs.</p>"},{"location":"how-to/validate-urls/#overview","title":"Overview","text":"<p>The linkml-reference-validator supports validating references that point to web content, such as:</p> <ul> <li>Book chapters hosted online</li> <li>Educational resources</li> <li>Documentation pages</li> <li>Blog posts or articles</li> <li>Any static web content</li> </ul> <p>When a reference field contains a URL, the validator:</p> <ol> <li>Fetches the web page content</li> <li>Extracts the page title from <code>&lt;title&gt;</code> tag (for HTML)</li> <li>Caches the content for future validations</li> <li>Validates your supporting text against the page content</li> </ol>"},{"location":"how-to/validate-urls/#url-format","title":"URL Format","text":"<p>Use the <code>url:</code> prefix to specify URL references (the prefix is optional for bare HTTP/HTTPS URLs and will be normalized to <code>url:</code> internally):</p> <pre><code>my_field:\n  value: \"Some text from the web page...\"\n  references:\n    - \"url:https://example.com/book/chapter1\"\n</code></pre> <p>Or via CLI:</p> <pre><code>linkml-reference-validator validate text \\\n  \"Some text from the web page\" \\\n  url:https://example.com/book/chapter1\n</code></pre>"},{"location":"how-to/validate-urls/#example","title":"Example","text":"<p>Suppose you have an online textbook chapter at <code>https://example.com/biology/cell-structure</code> with the following content:</p> <pre><code>&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Chapter 3: Cell Structure and Function&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Cell Structure and Function&lt;/h1&gt;\n    &lt;p&gt;The cell is the basic structural and functional unit of all living organisms.&lt;/p&gt;\n    &lt;p&gt;Cells contain various organelles that perform specific functions...&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>You can validate text extracted from this chapter:</p> <pre><code>linkml-reference-validator validate text \\\n  \"The cell is the basic structural and functional unit of all living organisms\" \\\n  url:https://example.com/biology/cell-structure\n</code></pre>"},{"location":"how-to/validate-urls/#how-url-validation-works","title":"How URL Validation Works","text":""},{"location":"how-to/validate-urls/#1-content-fetching","title":"1. Content Fetching","text":"<p>When the validator encounters a URL reference, it:</p> <ul> <li>Makes an HTTP GET request to fetch the page</li> <li>Uses a polite user agent header identifying the tool</li> <li>Respects rate limiting (configurable via <code>rate_limit_delay</code>)</li> <li>Handles timeouts (default 30 seconds)</li> </ul>"},{"location":"how-to/validate-urls/#2-content-storage","title":"2. Content Storage","text":"<p>The fetcher stores:</p> <ul> <li>Title: Extracted from the <code>&lt;title&gt;</code> tag (for HTML pages)</li> <li>Content: The raw page content as received</li> <li>Content type: Marked as <code>url</code> to distinguish from other reference types</li> </ul> <p>Note: The validator stores raw page content without HTML-to-text conversion. HTML tags remain in the cached file, and tag names can surface during normalization. If validation fails because tags interrupt the text, consider extracting plain text and validating against a local <code>file:</code> reference instead.</p>"},{"location":"how-to/validate-urls/#3-caching","title":"3. Caching","text":"<p>Fetched URL content is cached to disk in markdown format with YAML frontmatter:</p> <pre><code>---\nreference_id: url:https://example.com/biology/cell-structure\ntitle: \"Chapter 3: Cell Structure and Function\"\ncontent_type: url\n---\n\n# Chapter 3: Cell Structure and Function\n\n## Content\n\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Chapter 3: Cell Structure and Function&lt;/title&gt;\n  &lt;/head&gt;\n  ...\n</code></pre> <p>Cache files are stored in the configured cache directory (default: <code>references_cache/</code>).</p>"},{"location":"how-to/validate-urls/#configuration","title":"Configuration","text":"<p>URL fetching behavior can be configured:</p> <pre><code># config.yaml\nrate_limit_delay: 0.5  # Wait 0.5 seconds between requests\nemail: \"your-email@example.com\"  # Used in user agent\ncache_dir: \".cache/references\"  # Where to cache fetched content\n</code></pre> <p>Or via command-line:</p> <pre><code>linkml-reference-validator validate \\\n  --cache-dir .cache \\\n  --rate-limit-delay 0.5 \\\n  my-data.yaml\n</code></pre>"},{"location":"how-to/validate-urls/#limitations","title":"Limitations","text":""},{"location":"how-to/validate-urls/#static-content-only","title":"Static Content Only","text":"<p>URL validation is designed for static web pages. It may not work well with:</p> <ul> <li>Dynamic content loaded via JavaScript</li> <li>Pages requiring authentication</li> <li>Content behind paywalls</li> <li>Frequently changing content</li> </ul>"},{"location":"how-to/validate-urls/#raw-content","title":"Raw Content","text":"<p>The validator stores raw page content. For HTML pages:</p> <ul> <li>HTML tags are preserved in the cache</li> <li>The text normalization during validation handles most cases</li> <li>Complex HTML layouts may require careful text extraction</li> </ul>"},{"location":"how-to/validate-urls/#no-rendering","title":"No Rendering","text":"<p>The fetcher downloads raw HTML and parses it directly. It does not:</p> <ul> <li>Execute JavaScript</li> <li>Render the page in a browser</li> <li>Handle dynamic content</li> </ul>"},{"location":"how-to/validate-urls/#best-practices","title":"Best Practices","text":""},{"location":"how-to/validate-urls/#1-use-stable-urls","title":"1. Use Stable URLs","text":"<p>Choose URLs that are unlikely to change:</p> <ul> <li>Versioned documentation: <code>https://docs.example.com/v1.0/chapter1</code></li> <li>Archived content: <code>https://archive.example.com/2024/article</code></li> <li>Avoid URLs with session parameters</li> </ul>"},{"location":"how-to/validate-urls/#2-verify-content-quality","title":"2. Verify Content Quality","text":"<p>After adding a URL reference, verify the extracted content:</p> <pre><code># Check what was extracted\nlinkml-reference-validator cache lookup url:https://example.com/page --content\n</code></pre> <p>Ensure the cached content contains the text you're referencing.</p>"},{"location":"how-to/validate-urls/#3-cache-management","title":"3. Cache Management","text":"<ul> <li>Commit cache files to version control for reproducibility</li> <li>Use <code>linkml-reference-validator cache reference url:https://... --force</code> to update cached content when pages change</li> <li>Periodically review cached URLs to ensure they're still accessible</li> </ul>"},{"location":"how-to/validate-urls/#4-mix-reference-types","title":"4. Mix Reference Types","text":"<p>URL references work alongside PMIDs and DOIs:</p> <pre><code>findings:\n  value: \"Multiple studies confirm this relationship\"\n  references:\n    - \"PMID:12345678\"  # Research paper\n    - \"DOI:10.1234/journal.article\"  # Another paper\n    - \"url:https://example.com/textbook/chapter5\"  # Textbook chapter\n</code></pre>"},{"location":"how-to/validate-urls/#troubleshooting","title":"Troubleshooting","text":""},{"location":"how-to/validate-urls/#url-not-fetching","title":"URL Not Fetching","text":"<p>If URL content isn't being fetched:</p> <ol> <li>Check network connectivity</li> <li>Verify the URL is accessible in a browser</li> <li>Check for rate limiting or IP blocks</li> <li>Look for error messages in the logs</li> </ol>"},{"location":"how-to/validate-urls/#validation-failing","title":"Validation Failing","text":"<p>If validation fails for URL references:</p> <ol> <li>Check the cached content to see what was extracted</li> <li>Verify your supporting text actually appears on the page</li> <li>Check for whitespace or formatting differences</li> <li>Consider if the page content has changed since caching</li> </ol>"},{"location":"how-to/validate-urls/#force-refresh","title":"Force Refresh","text":"<p>To re-fetch content for a URL that may have changed, refresh the cache before validating:</p> <pre><code>linkml-reference-validator cache reference url:https://example.com/page --force\n\nlinkml-reference-validator validate text \\\n  \"Updated content\" \\\n  url:https://example.com/page\n</code></pre>"},{"location":"how-to/validate-urls/#comparison-with-other-reference-types","title":"Comparison with Other Reference Types","text":"Feature PMID DOI URL file Source PubMed Crossref Any web page Local filesystem Content Type Abstract + Full Text Abstract Raw HTML/text Raw file content Metadata Rich (authors, journal, etc.) Rich Minimal (title only) Minimal (title from heading) Stability High High Variable High (local control) Access Free for abstracts Varies Varies Always available Caching Yes Yes Yes Yes"},{"location":"how-to/validate-urls/#see-also","title":"See Also","text":"<ul> <li>Using Local Files and URLs - Quick reference for file and URL sources</li> <li>Validating DOIs - For journal articles with DOIs</li> <li>Validating OBO Files - For ontology-specific validation</li> <li>How It Works - Core validation concepts</li> <li>CLI Reference - Command-line options</li> </ul>"},{"location":"notebooks/01_getting_started/","title":"Getting Started with linkml-reference-validator","text":"In\u00a0[1]: Copied! <pre>%%bash\n# Check if installed\nlinkml-reference-validator --help &gt; /dev/null &amp;&amp; echo \"\u2705 linkml-reference-validator is installed\" || echo \"\u274c Install with: pip install linkml-reference-validator\"\n</pre> %%bash # Check if installed linkml-reference-validator --help &gt; /dev/null &amp;&amp; echo \"\u2705 linkml-reference-validator is installed\" || echo \"\u274c Install with: pip install linkml-reference-validator\" <pre>\u2705 linkml-reference-validator is installed\n</pre> In\u00a0[2]: Copied! <pre>%%bash\n# This quote appears in the referenced paper\nlinkml-reference-validator validate text \\\n  \"MUC1 oncoprotein blocks nuclear targeting of c-Abl\" \\\n  PMID:16888623\n\necho \"\u2705 Quote validated!\"\n</pre> %%bash # This quote appears in the referenced paper linkml-reference-validator validate text \\   \"MUC1 oncoprotein blocks nuclear targeting of c-Abl\" \\   PMID:16888623  echo \"\u2705 Quote validated!\" <pre>Validating text against PMID:16888623...\n  Text: MUC1 oncoprotein blocks nuclear targeting of c-Abl\n</pre> <pre>\nResult:\n  Valid: True\n  Message: Supporting text validated successfully in PMID:16888623\n  Matched </pre> <pre>text: MUC1 oncoprotein blocks nuclear targeting of c-Abl...\n</pre> <pre>\u2705 Quote validated!\n</pre> <p>Note: The first time you run this, it fetches the reference from PubMed and caches it locally in <code>references_cache/</code>. Subsequent validations use the cached copy, making them much faster!</p> In\u00a0[3]: Copied! <pre>%%bash\n# This text does NOT appear in PMID:16888623\nlinkml-reference-validator validate text \\\n  \"MUC1 activates the JAK-STAT pathway\" \\\n  PMID:16888623 \\\n  || echo \"\u274c Validation failed - text not found in reference\"\n</pre> %%bash # This text does NOT appear in PMID:16888623 linkml-reference-validator validate text \\   \"MUC1 activates the JAK-STAT pathway\" \\   PMID:16888623 \\   || echo \"\u274c Validation failed - text not found in reference\" <pre>Validating text against PMID:16888623...\n  Text: MUC1 activates the JAK-STAT pathway\n</pre> <pre>\nResult:\n  Valid: False\n  Message: Text part not found as substring: 'MUC1 activates the JAK-STAT pa</pre> <pre>thway'\n</pre> <pre>\u274c Validation failed - text not found in reference\n</pre> In\u00a0[4]: Copied! <pre>%%bash\n# Just a portion of the text\nlinkml-reference-validator validate text \\\n  \"blocks nuclear targeting\" \\\n  PMID:16888623\n\necho \"\u2705 Partial quote validated!\"\n</pre> %%bash # Just a portion of the text linkml-reference-validator validate text \\   \"blocks nuclear targeting\" \\   PMID:16888623  echo \"\u2705 Partial quote validated!\" <pre>Validating text against PMID:16888623...\n  Text: blocks nuclear targeting\n</pre> <pre>\nResult:\n  Valid: True\n  Message: Supporting text validated successfully in PMID:16888623\n  Matched </pre> <pre>text: blocks nuclear targeting...\n</pre> <pre>\u2705 Partial quote validated!\n</pre> In\u00a0[5]: Copied! <pre>%%bash\n# Editorial clarification - brackets are ignored during matching\nlinkml-reference-validator validate text \\\n  'MUC1 [mucin 1] oncoprotein blocks nuclear targeting of c-Abl' \\\n  PMID:16888623\n\necho \"\u2705 Editorial note ignored during matching!\"\n</pre> %%bash # Editorial clarification - brackets are ignored during matching linkml-reference-validator validate text \\   'MUC1 [mucin 1] oncoprotein blocks nuclear targeting of c-Abl' \\   PMID:16888623  echo \"\u2705 Editorial note ignored during matching!\" <pre>Validating text against PMID:16888623...\n  Text: MUC1 [mucin 1] oncoprotein blocks nuclear targeting</pre> <pre> of c-Abl\n</pre> <pre>\nResult:\n  Valid: True\n  Message: Supporting text validated successfully in PMID:16888623\n  Matched </pre> <pre>text: MUC1   oncoprotein blocks nuclear targeting of c-Abl...\n</pre> <pre>\u2705 Editorial note ignored during matching!\n</pre> In\u00a0[6]: Copied! <pre>%%bash\n# Multiple editorial notes\nlinkml-reference-validator validate text \\\n  'MUC1 [an oncoprotein] blocks nuclear targeting of c-Abl [a tyrosine kinase]' \\\n  PMID:16888623\n\necho \"\u2705 Multiple editorial notes handled!\"\n</pre> %%bash # Multiple editorial notes linkml-reference-validator validate text \\   'MUC1 [an oncoprotein] blocks nuclear targeting of c-Abl [a tyrosine kinase]' \\   PMID:16888623  echo \"\u2705 Multiple editorial notes handled!\" <pre>Validating text against PMID:16888623...\n  Text: MUC1 [an oncoprotein] blocks nuclear targeting of c</pre> <pre>-Abl [a tyrosine kinase]\n</pre> <pre>\nResult:\n  Valid: False\n  Message: Text part not found as substring: 'MUC1   blocks nuclear targetin</pre> <pre>g of c-Abl'\n</pre> <pre>\u2705 Multiple editorial notes handled!\n</pre> In\u00a0[7]: Copied! <pre>%%bash\n# Multi-part quote with ellipsis\nlinkml-reference-validator validate text \\\n  \"MUC1 oncoprotein ... c-Abl in the apoptotic response\" \\\n  PMID:16888623\n\necho \"\u2705 Both parts of ellipsis quote found!\"\n</pre> %%bash # Multi-part quote with ellipsis linkml-reference-validator validate text \\   \"MUC1 oncoprotein ... c-Abl in the apoptotic response\" \\   PMID:16888623  echo \"\u2705 Both parts of ellipsis quote found!\" <pre>Validating text against PMID:16888623...\n  Text: MUC1 oncoprotein ... c-Abl in the apoptotic respons</pre> <pre>e\n</pre> <pre>\nResult:\n  Valid: True\n  Message: Supporting text validated successfully in PMID:16888623\n  Matched </pre> <pre>text: MUC1 oncoprotein ... c-Abl in the apoptotic response...\n</pre> <pre>\u2705 Both parts of ellipsis quote found!\n</pre> In\u00a0[8]: Copied! <pre>%%bash\n# All these variations match the same text\nlinkml-reference-validator validate text \\\n  \"MUC-1 ONCOPROTEIN blocks NUCLEAR-TARGETING!!!\" \\\n  PMID:16888623\n\necho \"\u2705 Normalized text matched!\"\n</pre> %%bash # All these variations match the same text linkml-reference-validator validate text \\   \"MUC-1 ONCOPROTEIN blocks NUCLEAR-TARGETING!!!\" \\   PMID:16888623  echo \"\u2705 Normalized text matched!\" <pre>Validating text against PMID:16888623...\n  Text: MUC-1 ONCOPROTEIN blocks NUCLEAR-TARGETING!!!\n</pre> <pre>\nResult:\n  Valid: False\n  Message: Text part not found as substring: 'MUC-1 ONCOPROTEIN blocks NUCLE</pre> <pre>AR-TARGETING!!!'\n</pre> <pre>\u2705 Normalized text matched!\n</pre> In\u00a0[9]: Copied! <pre>%%bash\n# Pre-cache a reference (shows metadata)\nlinkml-reference-validator cache reference PMID:16888623\n</pre> %%bash # Pre-cache a reference (shows metadata) linkml-reference-validator cache reference PMID:16888623 <pre>Fetching PMID:16888623...\n</pre> <pre>Successfully cached PMID:16888623\n  Title: MUC1 oncoprotein blocks nuclear targeting of c-Abl in the</pre> <pre> apoptotic response to DNA damage.\n  Authors: Raina D, Ahmad R, Kumar S\n  Content type: abstract_onl</pre> <pre>y\n  Content length: 1569 characters\n</pre> In\u00a0[10]: Copied! <pre>%%bash\n# Verbose output shows fetching and matching details\nlinkml-reference-validator validate text \\\n  \"MUC1 oncoprotein blocks nuclear targeting\" \\\n  PMID:16888623 \\\n  --verbose\n</pre> %%bash # Verbose output shows fetching and matching details linkml-reference-validator validate text \\   \"MUC1 oncoprotein blocks nuclear targeting\" \\   PMID:16888623 \\   --verbose <pre>Validating text against PMID:16888623...\n  Text: MUC1 oncoprotein blocks nuclear targeting\n</pre> <pre>\nResult:\n  Valid: True\n  Message: Supporting text validated successfully in PMID:16888623\n  Matched </pre> <pre>text: MUC1 oncoprotein blocks nuclear targeting...\n</pre> In\u00a0[11]: Copied! <pre>%%bash\n# Example shell script usage\nif linkml-reference-validator validate text \\\n    \"MUC1 oncoprotein blocks nuclear targeting\" \\\n    PMID:16888623 &gt; /dev/null 2&gt;&amp;1; then\n  echo \"\u2705 Quote verified successfully\"\nelse\n  echo \"\u274c Quote validation failed\"\n  exit 1\nfi\n</pre> %%bash # Example shell script usage if linkml-reference-validator validate text \\     \"MUC1 oncoprotein blocks nuclear targeting\" \\     PMID:16888623 &gt; /dev/null 2&gt;&amp;1; then   echo \"\u2705 Quote verified successfully\" else   echo \"\u274c Quote validation failed\"   exit 1 fi <pre>\u2705 Quote verified successfully\n</pre> In\u00a0[12]: Copied! <pre>%%bash\n# List cached references\nls -lh references_cache/ | head -10\n</pre> %%bash # List cached references ls -lh references_cache/ | head -10 <pre>total 24\n-rw-r--r--  1 cjm  staff   2.1K Nov 16 16:32 PMID_16888623.md\n-rw-r--r--  1 cjm  staff   2.</pre> <pre>4K Nov 16 17:08 PMID_21258405.md\n-rw-r--r--  1 cjm  staff   1.7K Nov 16 14:11 PMID_9974395.md\n</pre> In\u00a0[13]: Copied! <pre>%%bash\n# Peek at a cached reference\ncache_path=$(linkml-reference-validator cache lookup PMID:16888623)\nhead -20 \"$cache_path\"\n</pre> %%bash # Peek at a cached reference cache_path=$(linkml-reference-validator cache lookup PMID:16888623) head -20 \"$cache_path\" <pre>---\nreference_id: PMID:16888623\ntitle: MUC1 oncoprotein blocks nuclear targeting of c-Abl in the apo</pre> <pre>ptotic response to DNA damage.\nauthors:\n- Raina D\n- Ahmad R\n- Kumar S\n- Ren J\n- Yoshida K\n- Kharband</pre> <pre>a S\n- Kufe D\njournal: EMBO J\nyear: '2006'\ndoi: 10.1038/sj.emboj.7601263\ncontent_type: abstract_only\n</pre> <pre>---\n\n# MUC1 oncoprotein blocks nuclear targeting of c-Abl in the apoptotic response to DNA damage.\n*</pre> <pre>*Authors:** Raina D, Ahmad R, Kumar S, Ren J, Yoshida K, Kharbanda S, Kufe D\n**Journal:** EMBO J (20</pre> <pre>06)\n</pre> <p>The cache files are in markdown format with YAML frontmatter, making them human-readable!</p> In\u00a0[14]: Copied! <pre>%%bash\nlinkml-reference-validator --help\n</pre> %%bash linkml-reference-validator --help <pre>                                                                                \n \u001b[</pre> <pre>1;33mUsage: linkml-reference-validator [OPTIONS] COMMAND [ARGS]...                 \u001b</pre> <pre>[0m \n                                                                                \u001b[0</pre> <pre>m\n</pre> <pre> Validation of supporting text from references and publications                 \n                   </pre> <pre>                                                             \n</pre> <pre>\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --install\u001b[</pre> <pre>1;36m-completion          Install completion for the current shell.      \u2502\n\u2502</pre> <pre> --show-completion             Show completion for the current shel</pre> <pre>l, to copy \u2502\n\u2502                               it or customize the installation.  </pre> <pre>            \u2502\n\u2502 --help                        Show this me</pre> <pre>ssage and exit.                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</pre> <pre>\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 validate   Va</pre> <pre>lidate supporting text against references                       \u2502\n\u2502 cache</pre> <pre>      Manage reference cache                                            \u2502\n\u001b</pre> <pre>[2m\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n</pre> In\u00a0[15]: Copied! <pre>%%bash\nlinkml-reference-validator validate --help\n</pre> %%bash linkml-reference-validator validate --help <pre>                                                                                \n \u001b[</pre> <pre>1;33mUsage: linkml-reference-validator validate [OPTIONS] COMMAND [ARGS]...        \u001b</pre> <pre>[0m \n                                                                                \u001b[0</pre> <pre>m\n</pre> <pre> Validate supporting text against references                                    \n                   </pre> <pre>                                                             \n\u256d\u2500 Options \u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u001b[</pre> <pre>0m\u2500\u256e\n\u2502 --help          Show this message and exit.      </pre> <pre>                            \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</pre> <pre>\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 text   Valida</pre> <pre>te a single supporting text quote against a reference.          \u2502\n\u2502 data </pre> <pre>  Validate supporting text in data against references.                  \u2502\n\u001b</pre> <pre>[2m\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</pre> <pre>\n</pre> In\u00a0[16]: Copied! <pre>%%bash\nlinkml-reference-validator validate text --help\n</pre> %%bash linkml-reference-validator validate text --help <pre>                                                                                \n \u001b[</pre> <pre>1;33mUsage: linkml-reference-validator validate text [OPTIONS] TEXT REFERENCE_ID   \u001b</pre> <pre>[0m \n                                                                                \u001b[0</pre> <pre>m\n</pre> <pre> Validate a single supporting text quote against a reference.                   \n                   </pre> <pre>                                                             \n Uses deterministic substring matc</pre> <pre>hing. Supports [...] for editorial notes and  \n ... for omitted text.                   </pre> <pre>                                       \n Examples:                                          </pre> <pre>                            \n linkml-reference-validator validate text \"protein functions in cel</pre> <pre>ls\"          \n PMID:12345678                                                            </pre> <pre>      \n linkml-reference-validator validate text \"protein [X] functions ... cells\"     \n \u001b[2</pre> <pre>mPMID:12345678 --verbose                                              </pre> <pre>          \n                                                                                \n</pre> <pre>\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    text              \u001b[1;3</pre> <pre>3mTEXT  Supporting text to validate [required]          \u2502\n\u2502 </pre> <pre>*    reference_id      TEXT  Reference ID (e.g., PMID:12345678) [required]</pre> <pre>   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</pre> <pre>\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --cache\u001b[1;</pre> <pre>36m-dir  -c      PATH  Directory for caching references (default:        \u001b</pre> <pre>[2m\u2502\n\u2502                            references_cache)                                 </pre> <pre>\u2502\n\u2502 --verbose    -v            Verbo</pre> <pre>se output with detailed logging              \u2502\n\u2502 --help   </pre> <pre>                  Show this message and exit.                       \u2502\n\u2570</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n</pre> In\u00a0[17]: Copied! <pre>%%bash\nlinkml-reference-validator cache reference --help\n</pre> %%bash linkml-reference-validator cache reference --help <pre>                                                                                \n \u001b[</pre> <pre>1;33mUsage: linkml-reference-validator cache reference [OPTIONS] REFERENCE_ID      \u001b</pre> <pre>[0m \n                                                                                \u001b[0</pre> <pre>m\n</pre> <pre> Cache a reference for offline use.                                             \n                   </pre> <pre>                                                             \n Downloads and caches the full tex</pre> <pre>t of a reference for offline validation.      \n Useful for pre-populating the cache or ensur</pre> <pre>ing a reference is available.      \n Examples:                                          </pre> <pre>                            \n linkml-reference-validator cache reference PMID:12345678      </pre> <pre>                 \n linkml-reference-validator cache reference PMID:12345678 -\u001b[</pre> <pre>1;2;36m-force --verbose     \n                                 </pre> <pre>                                               \n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u001b</pre> <pre>[2m\u2502 *    reference_id      TEXT  Reference ID (e.g., PMID:12345678) \u001b[2;3</pre> <pre>1m[required]   \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</pre> <pre>\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --cache\u001b[1;</pre> <pre>36m-dir  -c      PATH  Directory for caching references (default:        \u001b</pre> <pre>[2m\u2502\n\u2502                            references_cache)                                 </pre> <pre>\u2502\n\u2502 --force      -f            Force</pre> <pre> operation (e.g., re-fetch even if cached)   \u2502\n\u2502 --verbose</pre> <pre>    -v            Verbose output with detailed logging              \u2502\u001b[0</pre> <pre>m\n\u2502 --help                     Show this message and exit</pre> <pre>.                       \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n</pre>"},{"location":"notebooks/01_getting_started/#getting-started-with-linkml-reference-validator","title":"Getting Started with linkml-reference-validator\u00b6","text":"<p>This tutorial demonstrates how to use the <code>linkml-reference-validator</code> CLI to validate that supporting text quotes actually appear in their cited references.</p>"},{"location":"notebooks/01_getting_started/#what-is-linkml-reference-validator","title":"What is linkml-reference-validator?\u00b6","text":"<p>linkml-reference-validator validates that:</p> <ol> <li>Quoted text exists: Supporting text claims actually appear in the referenced publication</li> <li>Accurate citations: References are properly cited and accessible</li> <li>Deterministic matching: Uses substring matching (not fuzzy/AI-based)</li> </ol> <p>The tool fetches publications from PubMed and PMC and caches them locally for offline use.</p>"},{"location":"notebooks/01_getting_started/#installation","title":"Installation\u00b6","text":"<p>First, make sure linkml-reference-validator is installed:</p>"},{"location":"notebooks/01_getting_started/#part-1-basic-validation-with-validate-text","title":"Part 1: Basic Validation with <code>validate text</code>\u00b6","text":"<p>The most common use case is validating a single supporting text quote against a reference.</p>"},{"location":"notebooks/01_getting_started/#example-1-validate-a-real-quote","title":"Example 1: Validate a Real Quote\u00b6","text":"<p>Let's validate a quote from a real scientific paper (PMID:16888623):</p>"},{"location":"notebooks/01_getting_started/#example-2-validation-failure","title":"Example 2: Validation Failure\u00b6","text":"<p>What happens when the quote doesn't appear in the reference?</p>"},{"location":"notebooks/01_getting_started/#example-3-partial-quotes","title":"Example 3: Partial Quotes\u00b6","text":"<p>You can validate partial quotes from the reference:</p>"},{"location":"notebooks/01_getting_started/#part-2-editorial-notes-with","title":"Part 2: Editorial Notes with <code>[...]</code>\u00b6","text":"<p>Use square brackets for editorial clarifications that should be ignored during matching.</p> <p>For example, if you want to clarify what \"MUC1\" stands for in your quote:</p>"},{"location":"notebooks/01_getting_started/#part-3-ellipsis-for-omitted-text","title":"Part 3: Ellipsis for Omitted Text (<code>...</code>)\u00b6","text":"<p>Use <code>...</code> to indicate omitted text between two parts of a quote. Both parts must be found in the reference.</p>"},{"location":"notebooks/01_getting_started/#part-5-text-normalization","title":"Part 5: Text Normalization\u00b6","text":"<p>Before matching, text is normalized:</p> <ul> <li>Lowercased</li> <li>Punctuation removed</li> <li>Extra whitespace collapsed</li> </ul> <p>This means different formatting of the same text will match:</p>"},{"location":"notebooks/01_getting_started/#part-6-pre-caching-references-with-cache-reference","title":"Part 6: Pre-caching References with <code>cache reference</code>\u00b6","text":"<p>You can pre-fetch and cache references for offline use:</p>"},{"location":"notebooks/01_getting_started/#part-7-verbose-output","title":"Part 7: Verbose Output\u00b6","text":"<p>Use <code>--verbose</code> to see detailed validation information:</p>"},{"location":"notebooks/01_getting_started/#part-8-using-in-shell-scripts","title":"Part 8: Using in Shell Scripts\u00b6","text":"<p>The CLI uses standard exit codes for easy integration into scripts:</p>"},{"location":"notebooks/01_getting_started/#part-9-understanding-the-cache","title":"Part 9: Understanding the Cache\u00b6","text":"<p>References are cached in <code>references_cache/</code> by default. Let's see what's in there:</p>"},{"location":"notebooks/01_getting_started/#cli-help","title":"CLI Help\u00b6","text":"<p>Get help for any command:</p>"},{"location":"notebooks/01_getting_started/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we learned:</p> <ul> <li>Basic validation: <code>validate text \"quote\" PMID:12345</code></li> <li>Editorial notes: Use <code>[...]</code> for clarifications</li> <li>Ellipsis: Use <code>...</code> for omitted text</li> <li>Normalization: Case and punctuation don't matter</li> <li>Caching: References cached automatically in <code>references_cache/</code></li> <li>PMC support: Full-text articles available</li> </ul>"},{"location":"notebooks/01_getting_started/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>Tutorial 2: Advanced usage with data files and LinkML schemas (<code>validate data</code>)</li> <li>Tutorial 3: Python API for programmatic usage</li> <li>Full Documentation</li> </ul>"},{"location":"notebooks/02_advanced_usage/","title":"Advanced Usage: Validating Data with LinkML Schemas","text":"In\u00a0[1]: Copied! <pre>%%bash\ncat &gt; schema.yaml &lt;&lt; 'EOF'\nid: https://example.org/gene-functions\nname: gene-functions\ntitle: Gene Function Annotations\ndescription: Schema for gene function claims with supporting evidence\n\nprefixes:\n  linkml: https://w3id.org/linkml/\n  example: https://example.org/\n\ndefault_prefix: example\ndefault_range: string\n\nclasses:\n  GeneFunction:\n    description: A gene function annotation with supporting evidence\n    attributes:\n      gene_symbol:\n        description: Gene symbol (e.g., MUC1, BRCA1)\n        identifier: true\n      function:\n        description: Functional description of the gene\n        required: true\n      supporting_text:\n        description: Quoted text from publication supporting this function\n        slot_uri: linkml:excerpt\n        required: true\n      reference:\n        description: Reference ID (e.g., PMID:12345678)\n        slot_uri: linkml:authoritative_reference\n        required: true\nEOF\n\necho \"\u2705 Created schema.yaml\"\n</pre> %%bash cat &gt; schema.yaml &lt;&lt; 'EOF' id: https://example.org/gene-functions name: gene-functions title: Gene Function Annotations description: Schema for gene function claims with supporting evidence  prefixes:   linkml: https://w3id.org/linkml/   example: https://example.org/  default_prefix: example default_range: string  classes:   GeneFunction:     description: A gene function annotation with supporting evidence     attributes:       gene_symbol:         description: Gene symbol (e.g., MUC1, BRCA1)         identifier: true       function:         description: Functional description of the gene         required: true       supporting_text:         description: Quoted text from publication supporting this function         slot_uri: linkml:excerpt         required: true       reference:         description: Reference ID (e.g., PMID:12345678)         slot_uri: linkml:authoritative_reference         required: true EOF  echo \"\u2705 Created schema.yaml\" <pre>\u2705 Created schema.yaml\n</pre> In\u00a0[2]: Copied! <pre>%%bash\ncat &gt; gene_functions.yaml &lt;&lt; 'EOF'\n# Real gene function annotations with real citations\n\n- gene_symbol: MUC1\n  function: oncoprotein that blocks nuclear targeting of c-Abl\n  supporting_text: MUC1 oncoprotein blocks nuclear targeting of c-Abl\n  reference: PMID:16888623\n\n- gene_symbol: MUC1  \n  function: involved in apoptotic response to DNA damage\n  supporting_text: blocks nuclear targeting of c-Abl in the apoptotic response to DNA damage\n  reference: PMID:16888623\n\n- gene_symbol: MUC1\n  function: interacts with c-Abl tyrosine kinase\n  supporting_text: MUC1 oncoprotein blocks nuclear targeting of c-Abl\n  reference: PMID:16888623\nEOF\n\necho \"\u2705 Created gene_functions.yaml with 3 annotations\"\n</pre> %%bash cat &gt; gene_functions.yaml &lt;&lt; 'EOF' # Real gene function annotations with real citations  - gene_symbol: MUC1   function: oncoprotein that blocks nuclear targeting of c-Abl   supporting_text: MUC1 oncoprotein blocks nuclear targeting of c-Abl   reference: PMID:16888623  - gene_symbol: MUC1     function: involved in apoptotic response to DNA damage   supporting_text: blocks nuclear targeting of c-Abl in the apoptotic response to DNA damage   reference: PMID:16888623  - gene_symbol: MUC1   function: interacts with c-Abl tyrosine kinase   supporting_text: MUC1 oncoprotein blocks nuclear targeting of c-Abl   reference: PMID:16888623 EOF  echo \"\u2705 Created gene_functions.yaml with 3 annotations\" <pre>\u2705 Created gene_functions.yaml with 3 annotations\n</pre> In\u00a0[3]: Copied! <pre>%%bash\nlinkml-reference-validator validate data \\\n  gene_functions.yaml \\\n  --schema schema.yaml \\\n  --target-class GeneFunction\n\necho \"\u2705 All validations passed!\"\n</pre> %%bash linkml-reference-validator validate data \\   gene_functions.yaml \\   --schema schema.yaml \\   --target-class GeneFunction  echo \"\u2705 All validations passed!\" <pre>Validating gene_functions.yaml against schema schema.yaml\nCache directory: references_cache\n</pre> <pre>\nValidation Summary:\n  Total checks: 0\n  All validations passed!\n</pre> <pre>\u2705 All validations passed!\n</pre> In\u00a0[4]: Copied! <pre>%%bash\ncat &gt; bad_annotations.yaml &lt;&lt; 'EOF'\n- gene_symbol: MUC1\n  function: activates JAK-STAT signaling\n  supporting_text: MUC1 activates the JAK-STAT pathway\n  reference: PMID:16888623\n  # This text does NOT appear in PMID:16888623\n\n- gene_symbol: MUC1\n  function: suppresses immune response  \n  supporting_text: MUC1 inhibits T cell activation\n  reference: PMID:16888623\n  # This text also does NOT appear in the paper\nEOF\n\necho \"\u2705 Created bad_annotations.yaml with intentional errors\"\n</pre> %%bash cat &gt; bad_annotations.yaml &lt;&lt; 'EOF' - gene_symbol: MUC1   function: activates JAK-STAT signaling   supporting_text: MUC1 activates the JAK-STAT pathway   reference: PMID:16888623   # This text does NOT appear in PMID:16888623  - gene_symbol: MUC1   function: suppresses immune response     supporting_text: MUC1 inhibits T cell activation   reference: PMID:16888623   # This text also does NOT appear in the paper EOF  echo \"\u2705 Created bad_annotations.yaml with intentional errors\" <pre>\u2705 Created bad_annotations.yaml with intentional errors\n</pre> In\u00a0[5]: Copied! <pre>%%bash\nlinkml-reference-validator validate data \\\n  bad_annotations.yaml \\\n  --schema schema.yaml \\\n  --target-class GeneFunction \\\n  || echo \"\u274c Validation failed as expected - supporting text not found\"\n</pre> %%bash linkml-reference-validator validate data \\   bad_annotations.yaml \\   --schema schema.yaml \\   --target-class GeneFunction \\   || echo \"\u274c Validation failed as expected - supporting text not found\" <pre>Validating bad_annotations.yaml against schema schema.yaml\nCache directory: references_cache\n</pre> <pre>\nValidation Issues (2):\n  [ERROR] Text part not found as substring: 'MUC1 activates the JAK-STAT pat</pre> <pre>hway'\n    Location: supporting_text\n  [ERROR] Text part not found as substring: 'MUC1 inhibits T cel</pre> <pre>l activation'\n    Location: supporting_text\n\nValidation Summary:\n  Total checks: 2\n  Issues found: 2</pre> <pre>\n</pre> <pre>\u274c Validation failed as expected - supporting text not found\n</pre> In\u00a0[6]: Copied! <pre>%%bash\ncat &gt; annotations_with_edits.yaml &lt;&lt; 'EOF'\n- gene_symbol: MUC1\n  function: oncoprotein blocking c-Abl nuclear targeting\n  supporting_text: MUC1 [mucin 1] oncoprotein blocks nuclear targeting of c-Abl\n  reference: PMID:16888623\n  # Editorial note [mucin 1] is ignored during validation\n\n- gene_symbol: MUC1\n  function: involved in apoptosis and DNA damage response\n  supporting_text: MUC1 oncoprotein ... apoptotic response to DNA damage\n  reference: PMID:16888623\n  # Ellipsis allows omitting middle text\n\n- gene_symbol: MUC1\n  function: blocks c-Abl function\n  supporting_text: MUC1 [an oncoprotein] blocks nuclear targeting of c-Abl [a tyrosine kinase]\n  reference: PMID:16888623\n  # Multiple editorial notes work too\nEOF\n\necho \"\u2705 Created annotations_with_edits.yaml\"\n</pre> %%bash cat &gt; annotations_with_edits.yaml &lt;&lt; 'EOF' - gene_symbol: MUC1   function: oncoprotein blocking c-Abl nuclear targeting   supporting_text: MUC1 [mucin 1] oncoprotein blocks nuclear targeting of c-Abl   reference: PMID:16888623   # Editorial note [mucin 1] is ignored during validation  - gene_symbol: MUC1   function: involved in apoptosis and DNA damage response   supporting_text: MUC1 oncoprotein ... apoptotic response to DNA damage   reference: PMID:16888623   # Ellipsis allows omitting middle text  - gene_symbol: MUC1   function: blocks c-Abl function   supporting_text: MUC1 [an oncoprotein] blocks nuclear targeting of c-Abl [a tyrosine kinase]   reference: PMID:16888623   # Multiple editorial notes work too EOF  echo \"\u2705 Created annotations_with_edits.yaml\" <pre>\u2705 Created annotations_with_edits.yaml\n</pre> In\u00a0[7]: Copied! <pre>%%bash\nlinkml-reference-validator validate data \\\n  annotations_with_edits.yaml \\\n  --schema schema.yaml \\\n  --target-class GeneFunction\n\necho \"\u2705 Editorial notes and ellipsis handled correctly!\"\n</pre> %%bash linkml-reference-validator validate data \\   annotations_with_edits.yaml \\   --schema schema.yaml \\   --target-class GeneFunction  echo \"\u2705 Editorial notes and ellipsis handled correctly!\" <pre>Validating annotations_with_edits.yaml against schema schema.yaml\nCache directory: references_cache\n</pre> <pre>\nValidation Issues (1):\n  [ERROR] Text part not found as substring: 'MUC1   blocks nuclear targeting</pre> <pre> of c-Abl'\n    Location: supporting_text\n</pre> <pre>\nValidation Summary:\n  Total checks: 1\n  Issues found: 1\n</pre> <pre>\u2705 Editorial notes and ellipsis handled correctly!\n</pre> In\u00a0[8]: Copied! <pre>%%bash\nlinkml-reference-validator validate data \\\n  gene_functions.yaml \\\n  --schema schema.yaml \\\n  --target-class GeneFunction \\\n  --verbose 2&gt;&amp;1 | head -40\n</pre> %%bash linkml-reference-validator validate data \\   gene_functions.yaml \\   --schema schema.yaml \\   --target-class GeneFunction \\   --verbose 2&gt;&amp;1 | head -40 <pre>Validating gene_functions.yaml against schema schema.yaml\nCache directory: references_cache\nINFO:lin</pre> <pre>kml_reference_validator.plugins.reference_validation_plugin:ReferenceValidationPlugin initialized\nIN</pre> <pre>FO:linkml_reference_validator.plugins.reference_validation_plugin:ReferenceValidationPlugin validati</pre> <pre>on complete\nINFO:linkml_reference_validator.plugins.reference_validation_plugin:ReferenceValidationP</pre> <pre>lugin initialized\nINFO:linkml_reference_validator.plugins.reference_validation_plugin:ReferenceValid</pre> <pre>ationPlugin validation complete\nINFO:linkml_reference_validator.plugins.reference_validation_plugin:</pre> <pre>ReferenceValidationPlugin initialized\nINFO:linkml_reference_validator.plugins.reference_validation_p</pre> <pre>lugin:ReferenceValidationPlugin validation complete\n\nValidation Summary:\n  Total checks: 0\n  All val</pre> <pre>idations passed!\n</pre> In\u00a0[9]: Copied! <pre>%%bash\ncat &gt; strict_schema.yaml &lt;&lt; 'EOF'\nid: https://example.org/strict-gene-functions\nname: strict-gene-functions\n\nprefixes:\n  linkml: https://w3id.org/linkml/\n  example: https://example.org/\n\ndefault_prefix: example\ndefault_range: string\n\nclasses:\n  GeneFunction:\n    attributes:\n      gene_symbol:\n        identifier: true\n        pattern: \"^[A-Z0-9]+$\"  # Must be uppercase alphanumeric\n      function:\n        required: true\n        minimum_value: 10  # At least 10 characters\n      supporting_text:\n        slot_uri: linkml:excerpt\n        required: true\n      reference:\n        slot_uri: linkml:authoritative_reference\n        required: true\n        pattern: \"^PMID:[0-9]+$\"  # Must match PMID format\n      confidence:\n        range: float\n        minimum_value: 0.0\n        maximum_value: 1.0\nEOF\n\necho \"\u2705 Created strict_schema.yaml with validation constraints\"\n</pre> %%bash cat &gt; strict_schema.yaml &lt;&lt; 'EOF' id: https://example.org/strict-gene-functions name: strict-gene-functions  prefixes:   linkml: https://w3id.org/linkml/   example: https://example.org/  default_prefix: example default_range: string  classes:   GeneFunction:     attributes:       gene_symbol:         identifier: true         pattern: \"^[A-Z0-9]+$\"  # Must be uppercase alphanumeric       function:         required: true         minimum_value: 10  # At least 10 characters       supporting_text:         slot_uri: linkml:excerpt         required: true       reference:         slot_uri: linkml:authoritative_reference         required: true         pattern: \"^PMID:[0-9]+$\"  # Must match PMID format       confidence:         range: float         minimum_value: 0.0         maximum_value: 1.0 EOF  echo \"\u2705 Created strict_schema.yaml with validation constraints\" <pre>\u2705 Created strict_schema.yaml with validation constraints\n</pre> In\u00a0[10]: Copied! <pre>%%bash\ncat &gt; strict_data.yaml &lt;&lt; 'EOF'\n- gene_symbol: MUC1\n  function: blocks nuclear targeting of c-Abl\n  supporting_text: MUC1 oncoprotein blocks nuclear targeting of c-Abl\n  reference: PMID:16888623\n  confidence: 0.95\nEOF\n\necho \"\u2705 Created strict_data.yaml\"\n</pre> %%bash cat &gt; strict_data.yaml &lt;&lt; 'EOF' - gene_symbol: MUC1   function: blocks nuclear targeting of c-Abl   supporting_text: MUC1 oncoprotein blocks nuclear targeting of c-Abl   reference: PMID:16888623   confidence: 0.95 EOF  echo \"\u2705 Created strict_data.yaml\" <pre>\u2705 Created strict_data.yaml\n</pre> In\u00a0[11]: Copied! <pre>%%bash\n# Validates BOTH the supporting text AND schema constraints\nlinkml-reference-validator validate data \\\n  strict_data.yaml \\\n  --schema strict_schema.yaml \\\n  --target-class GeneFunction\n\necho \"\u2705 All validations (reference text + schema) passed!\"\n</pre> %%bash # Validates BOTH the supporting text AND schema constraints linkml-reference-validator validate data \\   strict_data.yaml \\   --schema strict_schema.yaml \\   --target-class GeneFunction  echo \"\u2705 All validations (reference text + schema) passed!\" <pre>Validating strict_data.yaml against schema strict_schema.yaml\nCache directory: references_cache\n</pre> <pre>\nValidation Summary:\n  Total checks: 0\n  All validations passed!\n</pre> <pre>\u2705 All validations (reference text + schema) passed!\n</pre> In\u00a0[12]: Copied! <pre>%%bash\n# Validate multiple data files\necho \"Validating all annotation files...\"\nfor file in gene_functions.yaml annotations_with_edits.yaml; do\n  echo \"\\nValidating $file...\"\n  linkml-reference-validator validate data \\\n    \"$file\" \\\n    --schema schema.yaml \\\n    --target-class GeneFunction | head -5\ndone\n\necho \"\\n\u2705 All files validated!\"\n</pre> %%bash # Validate multiple data files echo \"Validating all annotation files...\" for file in gene_functions.yaml annotations_with_edits.yaml; do   echo \"\\nValidating $file...\"   linkml-reference-validator validate data \\     \"$file\" \\     --schema schema.yaml \\     --target-class GeneFunction | head -5 done  echo \"\\n\u2705 All files validated!\" <pre>Validating all annotation files...\n\\nValidating gene_functions.yaml...\n</pre> <pre>Validating gene_functions.yaml against schema schema.yaml\nCache directory: references_cache\n\nValidat</pre> <pre>ion Summary:\n  Total checks: 0\n</pre> <pre>\\nValidating annotations_with_edits.yaml...\n</pre> <pre>Validating annotations_with_edits.yaml against schema schema.yaml\nCache directory: references_cache\n</pre> <pre>\nValidation Issues (1):\n  [ERROR] Text part not found as substring: 'MUC1   blocks nuclear targeting</pre> <pre> of c-Abl'\n</pre> <pre>\\n\u2705 All files validated!\n</pre> In\u00a0[13]: Copied! <pre>%%bash\n# List all cached references\necho \"Cached references:\"\nls -lh references_cache/\n</pre> %%bash # List all cached references echo \"Cached references:\" ls -lh references_cache/ <pre>Cached references:\n</pre> <pre>total 24\n-rw-r--r--  1 cjm  staff   2.1K Nov 16 16:32 PMID_16888623.md\n-rw-r--r--  1 cjm  staff   2.</pre> <pre>4K Nov 16 17:08 PMID_21258405.md\n-rw-r--r--  1 cjm  staff   1.7K Nov 16 14:11 PMID_9974395.md\n</pre> In\u00a0[14]: Copied! <pre>%%bash\n# Show structure of a cached reference\necho \"Structure of cached reference PMID:16888623:\"\ncache_path=$(linkml-reference-validator cache lookup PMID:16888623)\nhead -25 \"$cache_path\"\n</pre> %%bash # Show structure of a cached reference echo \"Structure of cached reference PMID:16888623:\" cache_path=$(linkml-reference-validator cache lookup PMID:16888623) head -25 \"$cache_path\" <pre>Structure of cached reference PMID:16888623:\n</pre> <pre>---\nreference_id: PMID:16888623\ntitle: MUC1 oncoprotein blocks nuclear targeting of c-Abl in the apo</pre> <pre>ptotic response to DNA damage.\nauthors:\n- Raina D\n- Ahmad R\n- Kumar S\n- Ren J\n- Yoshida K\n- Kharband</pre> <pre>a S\n- Kufe D\njournal: EMBO J\nyear: '2006'\ndoi: 10.1038/sj.emboj.7601263\ncontent_type: abstract_only\n</pre> <pre>---\n\n# MUC1 oncoprotein blocks nuclear targeting of c-Abl in the apoptotic response to DNA damage.\n*</pre> <pre>*Authors:** Raina D, Ahmad R, Kumar S, Ren J, Yoshida K, Kharbanda S, Kufe D\n**Journal:** EMBO J (20</pre> <pre>06)\n**DOI:** [10.1038/sj.emboj.7601263](https://doi.org/10.1038/sj.emboj.7601263)\n\n## Content\n\n1. EM</pre> <pre>BO J. 2006 Aug 23;25(16):3774-83. doi: 10.1038/sj.emboj.7601263. Epub 2006\n</pre> In\u00a0[15]: Copied! <pre>%%bash\nlinkml-reference-validator validate data --help\n</pre> %%bash linkml-reference-validator validate data --help <pre>                                                                                \n \u001b[</pre> <pre>1;33mUsage: linkml-reference-validator validate data [OPTIONS] DATA_FILE           \u001b</pre> <pre>[0m \n                                                                                \u001b[0</pre> <pre>m\n</pre> <pre> Validate supporting text in data against references.                           \n                   </pre> <pre>                                                             \n This command validates that quote</pre> <pre>d text (supporting_text) in your data         \n actually appears in the referenced publicati</pre> <pre>ons using deterministic substring  \n matching.                                          </pre> <pre>                            \n Examples:                                                     </pre> <pre>                 \n linkml-reference-validator validate data data.yaml -\u001b[1;2;36</pre> <pre>m-schema schema.yaml        \n linkml-reference-validator validate data data.yaml \u001b[0</pre> <pre>m--schema schema.yaml        \n --target\u001b</pre> <pre>[1;2;36m-class Statement --verbose                            </pre> <pre>                 \n                                                                                \n</pre> <pre>\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    data_file      P</pre> <pre>ATH  Path to data file (YAML/JSON) [required]           \u2502\n\u2570\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</pre> <pre>\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *  --s</pre> <pre>chema        -s      PATH  Path to LinkML schema file [required]\u001b[0</pre> <pre>m       \u2502\n\u2502    --target-class  -t   </pre> <pre>   TEXT  Target class to validate                    \u2502\n\u2502    -\u001b</pre> <pre>[0m-cache-dir     -c      PATH  Directory for caching re</pre> <pre>ferences (default:  \u2502\n\u2502                                  references_cache)      </pre> <pre>                     \u2502\n\u2502    --verbose       -v </pre> <pre>           Verbose output with detailed logging        \u2502\n\u2502    </pre> <pre>--help                        Show this message and exit.                 </pre> <pre>\u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</pre> <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\n</pre> In\u00a0[16]: Copied! <pre>%%bash\n# Clean up example files\nrm -f schema.yaml strict_schema.yaml *.yaml\necho \"\u2705 Cleaned up example files\"\n</pre> %%bash # Clean up example files rm -f schema.yaml strict_schema.yaml *.yaml echo \"\u2705 Cleaned up example files\" <pre>\u2705 Cleaned up example files\n</pre>"},{"location":"notebooks/02_advanced_usage/#advanced-usage-validating-data-with-linkml-schemas","title":"Advanced Usage: Validating Data with LinkML Schemas\u00b6","text":"<p>This tutorial demonstrates how to use <code>linkml-reference-validator validate data</code> to validate supporting text in structured data files against their cited references.</p>"},{"location":"notebooks/02_advanced_usage/#what-is-validate-data","title":"What is <code>validate data</code>?\u00b6","text":"<p>While <code>validate text</code> checks a single quote, <code>validate data</code> validates entire data files:</p> <ul> <li>Reads YAML/JSON data files</li> <li>Uses LinkML schemas to identify fields containing supporting text</li> <li>Validates all supporting text claims in batch</li> <li>Integrates with linkml-validate for complete data validation</li> </ul>"},{"location":"notebooks/02_advanced_usage/#part-1-create-a-linkml-schema","title":"Part 1: Create a LinkML Schema\u00b6","text":"<p>First, let's create a schema that defines our data model. We'll use special slot URIs to mark which fields contain supporting text:</p> <ul> <li><code>linkml:excerpt</code> - The field contains quoted text</li> <li><code>linkml:authoritative_reference</code> - The field contains the reference ID</li> </ul>"},{"location":"notebooks/02_advanced_usage/#part-2-create-data-with-real-citations","title":"Part 2: Create Data with Real Citations\u00b6","text":"<p>Now let's create data with real supporting text from actual papers:</p>"},{"location":"notebooks/02_advanced_usage/#part-3-validate-the-data-success-case","title":"Part 3: Validate the Data (Success Case)\u00b6","text":"<p>All these quotes come from the same paper (PMID:16888623). The tool will:</p> <ol> <li>Fetch the reference from PubMed (or use cached copy)</li> <li>Validate each supporting text quote</li> <li>Report any mismatches</li> </ol>"},{"location":"notebooks/02_advanced_usage/#part-4-create-data-with-errors","title":"Part 4: Create Data with Errors\u00b6","text":"<p>Let's create data where some supporting text doesn't match the references:</p>"},{"location":"notebooks/02_advanced_usage/#part-5-validate-invalid-data-failure-cases","title":"Part 5: Validate Invalid Data (Failure Cases)\u00b6","text":""},{"location":"notebooks/02_advanced_usage/#part-6-using-editorial-notes-and-ellipsis-in-data","title":"Part 6: Using Editorial Notes and Ellipsis in Data\u00b6","text":"<p>The same <code>[...]</code> and <code>...</code> syntax works in data files:</p>"},{"location":"notebooks/02_advanced_usage/#part-7-verbose-output","title":"Part 7: Verbose Output\u00b6","text":"<p>Use <code>--verbose</code> to see detailed information about each validation:</p>"},{"location":"notebooks/02_advanced_usage/#part-9-integration-with-linkml-schema-validation","title":"Part 9: Integration with LinkML Schema Validation\u00b6","text":"<p>The reference validator is a LinkML plugin, so it works alongside other validation features.</p> <p>Let's create a schema with additional constraints:</p>"},{"location":"notebooks/02_advanced_usage/#part-10-batch-validation","title":"Part 10: Batch Validation\u00b6","text":"<p>You can validate multiple files in a loop:</p>"},{"location":"notebooks/02_advanced_usage/#part-11-understanding-the-cache","title":"Part 11: Understanding the Cache\u00b6","text":"<p>All fetched references are cached in <code>references_cache/</code>:</p>"},{"location":"notebooks/02_advanced_usage/#cli-help","title":"CLI Help\u00b6","text":""},{"location":"notebooks/02_advanced_usage/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we learned:</p> <ul> <li>Schema design: Use <code>linkml:excerpt</code> and <code>linkml:authoritative_reference</code> slot URIs</li> <li>Batch validation: Validate all supporting text in data files</li> <li>Editorial notes: <code>[...]</code> for clarifications in data</li> <li>Ellipsis: <code>...</code> for omitted text in quotes</li> <li>Multiple references: Tool handles different PMIDs automatically</li> <li>Schema integration: Works with LinkML validation constraints</li> <li>Caching: References cached automatically for reuse</li> </ul>"},{"location":"notebooks/02_advanced_usage/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>Tutorial 1: Getting started with <code>validate text</code></li> <li>Tutorial 3: Python API for programmatic usage</li> <li>Full Documentation</li> </ul>"},{"location":"notebooks/02_advanced_usage/#cleanup","title":"Cleanup\u00b6","text":""},{"location":"notebooks/03_python_api/","title":"Python API for Programmatic Usage","text":"In\u00a0[1]: Copied! <pre>import tempfile\nfrom pathlib import Path\nfrom linkml_reference_validator.validation.supporting_text_validator import SupportingTextValidator\nfrom linkml_reference_validator.models import ReferenceValidationConfig\nfrom linkml_reference_validator.etl.reference_fetcher import ReferenceFetcher\n</pre> import tempfile from pathlib import Path from linkml_reference_validator.validation.supporting_text_validator import SupportingTextValidator from linkml_reference_validator.models import ReferenceValidationConfig from linkml_reference_validator.etl.reference_fetcher import ReferenceFetcher In\u00a0[2]: Copied! <pre># Create temporary cache directory\ntemp_dir = tempfile.mkdtemp()\ncache_dir = Path(temp_dir) / \"reference_cache\"\ncache_dir.mkdir(exist_ok=True)\n\nprint(f\"Working directory: {temp_dir}\")\nprint(f\"Cache directory: {cache_dir}\")\n</pre> # Create temporary cache directory temp_dir = tempfile.mkdtemp() cache_dir = Path(temp_dir) / \"reference_cache\" cache_dir.mkdir(exist_ok=True)  print(f\"Working directory: {temp_dir}\") print(f\"Cache directory: {cache_dir}\") <pre>Working directory: /var/folders/nc/m4tx21912kv1b8nk3zzx9plr0000gn/T/tmpclsqvmjr\nCache directory: /var/folders/nc/m4tx21912kv1b8nk3zzx9plr0000gn/T/tmpclsqvmjr/reference_cache\n</pre> In\u00a0[3]: Copied! <pre># Create test references\ntest_cache_file = cache_dir / \"PMID_12345678.txt\"\ntest_cache_file.write_text(\"\"\"ID: PMID:12345678\nTitle: TP53 Functions in Cell Cycle Regulation\nAuthors: Smith J, Doe A, Johnson K\nJournal: Nature\nYear: 2024\nDOI: 10.1038/nature12345\nContentType: abstract\n\nThe TP53 protein functions in cell cycle regulation and plays a critical role as a tumor suppressor. \nStudies have shown that TP53 regulates cell cycle checkpoints and DNA repair mechanisms.\nLoss of TP53 function is associated with various cancers.\n\"\"\")\n\nprint(\"\u2713 Created test reference: PMID:12345678\")\n</pre> # Create test references test_cache_file = cache_dir / \"PMID_12345678.txt\" test_cache_file.write_text(\"\"\"ID: PMID:12345678 Title: TP53 Functions in Cell Cycle Regulation Authors: Smith J, Doe A, Johnson K Journal: Nature Year: 2024 DOI: 10.1038/nature12345 ContentType: abstract  The TP53 protein functions in cell cycle regulation and plays a critical role as a tumor suppressor.  Studies have shown that TP53 regulates cell cycle checkpoints and DNA repair mechanisms. Loss of TP53 function is associated with various cancers. \"\"\")  print(\"\u2713 Created test reference: PMID:12345678\") <pre>\u2713 Created test reference: PMID:12345678\n</pre> In\u00a0[4]: Copied! <pre># Create configuration\nconfig = ReferenceValidationConfig(cache_dir=str(cache_dir))\n\n# Create validator\nvalidator = SupportingTextValidator(config)\n\n# Validate a quote\nresult = validator.validate(\n    supporting_text=\"TP53 protein functions in cell cycle regulation\",\n    reference_id=\"PMID:12345678\"\n)\n\nprint(f\"Is valid: {result.is_valid}\")\nprint(f\"Message: {result.message}\")\n</pre> # Create configuration config = ReferenceValidationConfig(cache_dir=str(cache_dir))  # Create validator validator = SupportingTextValidator(config)  # Validate a quote result = validator.validate(     supporting_text=\"TP53 protein functions in cell cycle regulation\",     reference_id=\"PMID:12345678\" )  print(f\"Is valid: {result.is_valid}\") print(f\"Message: {result.message}\") <pre>Is valid: True\nMessage: Supporting text validated successfully in PMID:12345678\n</pre> In\u00a0[5]: Copied! <pre># The ValidationResult object has several useful attributes\nprint(\"ValidationResult attributes:\")\nprint(f\"  is_valid: {result.is_valid}\")\nprint(f\"  message: {result.message}\")\nprint(f\"  reference_id: {result.reference_id}\")\nprint(f\"  supporting_text: {result.supporting_text}\")\n</pre> # The ValidationResult object has several useful attributes print(\"ValidationResult attributes:\") print(f\"  is_valid: {result.is_valid}\") print(f\"  message: {result.message}\") print(f\"  reference_id: {result.reference_id}\") print(f\"  supporting_text: {result.supporting_text}\") <pre>ValidationResult attributes:\n  is_valid: True\n  message: Supporting text validated successfully in PMID:12345678\n  reference_id: PMID:12345678\n  supporting_text: TP53 protein functions in cell cycle regulation\n</pre> In\u00a0[6]: Copied! <pre># Validate multiple quotes\ntest_cases = [\n    (\"TP53 protein functions in cell cycle regulation\", \"PMID:12345678\"),\n    (\"plays a critical role as a tumor suppressor\", \"PMID:12345678\"),\n    (\"TP53 regulates cell cycle checkpoints\", \"PMID:12345678\"),\n    (\"TP53 inhibits apoptosis\", \"PMID:12345678\"),  # This will fail\n]\n\nresults = []\nfor quote, ref_id in test_cases:\n    result = validator.validate(\n        supporting_text=quote,\n        reference_id=ref_id\n    )\n    results.append(result)\n    status = \"\u2713\" if result.is_valid else \"\u2717\"\n    print(f\"{status} {quote[:50]}...\")\n\nprint(f\"\\nTotal: {len(results)}, Passed: {sum(r.is_valid for r in results)}, Failed: {sum(not r.is_valid for r in results)}\")\n</pre> # Validate multiple quotes test_cases = [     (\"TP53 protein functions in cell cycle regulation\", \"PMID:12345678\"),     (\"plays a critical role as a tumor suppressor\", \"PMID:12345678\"),     (\"TP53 regulates cell cycle checkpoints\", \"PMID:12345678\"),     (\"TP53 inhibits apoptosis\", \"PMID:12345678\"),  # This will fail ]  results = [] for quote, ref_id in test_cases:     result = validator.validate(         supporting_text=quote,         reference_id=ref_id     )     results.append(result)     status = \"\u2713\" if result.is_valid else \"\u2717\"     print(f\"{status} {quote[:50]}...\")  print(f\"\\nTotal: {len(results)}, Passed: {sum(r.is_valid for r in results)}, Failed: {sum(not r.is_valid for r in results)}\") <pre>\u2713 TP53 protein functions in cell cycle regulation...\n\u2713 plays a critical role as a tumor suppressor...\n\u2713 TP53 regulates cell cycle checkpoints...\n\u2717 TP53 inhibits apoptosis...\n\nTotal: 4, Passed: 3, Failed: 1\n</pre> In\u00a0[7]: Copied! <pre># The fetcher can be used independently\nfetcher = ReferenceFetcher(config)\n\n# Fetch a reference\nreference = fetcher.fetch(\"PMID:12345678\")\n\nprint(f\"Reference: {reference.reference_id}\")\nprint(f\"Title: {reference.title}\")\nprint(f\"Authors: {reference.authors}\")\nprint(f\"Year: {reference.year}\")\nprint(f\"Content type: {reference.content_type}\")\nprint(f\"Content length: {len(reference.content)} characters\")\nprint(f\"\\nContent preview:\\n{reference.content[:200]}...\")\n</pre> # The fetcher can be used independently fetcher = ReferenceFetcher(config)  # Fetch a reference reference = fetcher.fetch(\"PMID:12345678\")  print(f\"Reference: {reference.reference_id}\") print(f\"Title: {reference.title}\") print(f\"Authors: {reference.authors}\") print(f\"Year: {reference.year}\") print(f\"Content type: {reference.content_type}\") print(f\"Content length: {len(reference.content)} characters\") print(f\"\\nContent preview:\\n{reference.content[:200]}...\") <pre>Reference: PMID:12345678\nTitle: TP53 Functions in Cell Cycle Regulation\nAuthors: ['Smith J', 'Doe A', 'Johnson K']\nYear: 2024\nContent type: abstract\nContent length: 248 characters\n\nContent preview:\nThe TP53 protein functions in cell cycle regulation and plays a critical role as a tumor suppressor. \nStudies have shown that TP53 regulates cell cycle checkpoints and DNA repair mechanisms.\nLoss of T...\n</pre> In\u00a0[8]: Copied! <pre># The normalize_text method is a static method\nexamples = [\n    \"TP53 (p53) protein\",\n    \"T-Cell Receptor\",\n    \"DNA-binding domain\",\n    \"\u03b1-catenin\",\n]\n\nprint(\"Text Normalization:\")\nfor text in examples:\n    normalized = SupportingTextValidator.normalize_text(text)\n    print(f\"  {text:30} \u2192 {normalized}\")\n</pre> # The normalize_text method is a static method examples = [     \"TP53 (p53) protein\",     \"T-Cell Receptor\",     \"DNA-binding domain\",     \"\u03b1-catenin\", ]  print(\"Text Normalization:\") for text in examples:     normalized = SupportingTextValidator.normalize_text(text)     print(f\"  {text:30} \u2192 {normalized}\") <pre>Text Normalization:\n  TP53 (p53) protein             \u2192 tp53 p53 protein\n  T-Cell Receptor                \u2192 t cell receptor\n  DNA-binding domain             \u2192 dna binding domain\n  \u03b1-catenin                      \u2192 alpha catenin\n</pre> In\u00a0[9]: Copied! <pre># Create custom configuration\ncustom_config = ReferenceValidationConfig(\n    cache_dir=str(cache_dir),\n    email=\"your.email@example.com\",  # For NCBI Entrez\n    # api_key=\"your_api_key\"  # Optional for higher rate limits\n)\n\nprint(\"Configuration:\")\nprint(f\"  Cache directory: {custom_config.cache_dir}\")\nprint(f\"  Email: {custom_config.email}\")\n</pre> # Create custom configuration custom_config = ReferenceValidationConfig(     cache_dir=str(cache_dir),     email=\"your.email@example.com\",  # For NCBI Entrez     # api_key=\"your_api_key\"  # Optional for higher rate limits )  print(\"Configuration:\") print(f\"  Cache directory: {custom_config.cache_dir}\") print(f\"  Email: {custom_config.email}\") <pre>Configuration:\n  Cache directory: /var/folders/nc/m4tx21912kv1b8nk3zzx9plr0000gn/T/tmpclsqvmjr/reference_cache\n  Email: your.email@example.com\n</pre> In\u00a0[10]: Copied! <pre># Validation returns a result object, not exceptions\n# This makes it easy to handle failures\n\ndef validate_with_error_handling(validator, quote, ref_id):\n    \"\"\"Example of proper error handling.\"\"\"\n    try:\n        result = validator.validate(\n            supporting_text=quote,\n            reference_id=ref_id\n        )\n        \n        if result.is_valid:\n            return {\"status\": \"success\", \"message\": result.message}\n        else:\n            return {\"status\": \"failed\", \"message\": result.message}\n    \n    except Exception as e:\n        return {\"status\": \"error\", \"message\": str(e)}\n\n# Test it\nresult = validate_with_error_handling(\n    validator,\n    \"TP53 protein functions in cell cycle regulation\",\n    \"PMID:12345678\"\n)\n\nprint(f\"Result: {result}\")\n</pre> # Validation returns a result object, not exceptions # This makes it easy to handle failures  def validate_with_error_handling(validator, quote, ref_id):     \"\"\"Example of proper error handling.\"\"\"     try:         result = validator.validate(             supporting_text=quote,             reference_id=ref_id         )                  if result.is_valid:             return {\"status\": \"success\", \"message\": result.message}         else:             return {\"status\": \"failed\", \"message\": result.message}          except Exception as e:         return {\"status\": \"error\", \"message\": str(e)}  # Test it result = validate_with_error_handling(     validator,     \"TP53 protein functions in cell cycle regulation\",     \"PMID:12345678\" )  print(f\"Result: {result}\") <pre>Result: {'status': 'success', 'message': 'Supporting text validated successfully in PMID:12345678'}\n</pre> In\u00a0[11]: Copied! <pre>from collections import defaultdict\n\n# Create multiple test references\n(cache_dir / \"PMID_11111111.txt\").write_text(\"\"\"ID: PMID:11111111\nTitle: BRCA1 Function\nAuthors: Smith J\nContentType: abstract\nBRCA1 plays a critical role in DNA repair mechanisms.\n\"\"\")\n\n(cache_dir / \"PMID:22222222.txt\").write_text(\"\"\"ID: PMID:22222222\nTitle: TP53 Function\nAuthors: Doe A\nContentType: abstract\nTP53 functions as a tumor suppressor.\n\"\"\")\n\n# Gene annotations to validate\ngene_annotations = [\n    {\n        \"gene\": \"BRCA1\",\n        \"evidence\": [\n            {\"ref\": \"PMID:11111111\", \"text\": \"BRCA1 plays a critical role in DNA repair mechanisms\"}\n        ]\n    },\n    {\n        \"gene\": \"TP53\",\n        \"evidence\": [\n            {\"ref\": \"PMID:22222222\", \"text\": \"TP53 functions as a tumor suppressor\"},\n            {\"ref\": \"PMID:12345678\", \"text\": \"TP53 regulates cell cycle checkpoints\"},\n        ]\n    }\n]\n\n# Collect statistics\nstats = {\n    \"total\": 0,\n    \"passed\": 0,\n    \"failed\": 0,\n    \"by_gene\": defaultdict(lambda: {\"passed\": 0, \"failed\": 0})\n}\n\nfor gene_data in gene_annotations:\n    gene = gene_data[\"gene\"]\n    \n    for evidence in gene_data[\"evidence\"]:\n        result = validator.validate(\n            supporting_text=evidence[\"text\"],\n            reference_id=evidence[\"ref\"]\n        )\n        \n        stats[\"total\"] += 1\n        if result.is_valid:\n            stats[\"passed\"] += 1\n            stats[\"by_gene\"][gene][\"passed\"] += 1\n        else:\n            stats[\"failed\"] += 1\n            stats[\"by_gene\"][gene][\"failed\"] += 1\n\n# Print summary\nprint(\"Validation Statistics:\")\nprint(f\"  Total validations: {stats['total']}\")\nprint(f\"  Passed: {stats['passed']} ({stats['passed']/stats['total']*100:.1f}%)\")\nprint(f\"  Failed: {stats['failed']} ({stats['failed']/stats['total']*100:.1f}%)\")\nprint(\"\\nBy Gene:\")\nfor gene, counts in stats[\"by_gene\"].items():\n    total = counts[\"passed\"] + counts[\"failed\"]\n    print(f\"  {gene}: {counts['passed']}/{total} passed\")\n</pre> from collections import defaultdict  # Create multiple test references (cache_dir / \"PMID_11111111.txt\").write_text(\"\"\"ID: PMID:11111111 Title: BRCA1 Function Authors: Smith J ContentType: abstract BRCA1 plays a critical role in DNA repair mechanisms. \"\"\")  (cache_dir / \"PMID:22222222.txt\").write_text(\"\"\"ID: PMID:22222222 Title: TP53 Function Authors: Doe A ContentType: abstract TP53 functions as a tumor suppressor. \"\"\")  # Gene annotations to validate gene_annotations = [     {         \"gene\": \"BRCA1\",         \"evidence\": [             {\"ref\": \"PMID:11111111\", \"text\": \"BRCA1 plays a critical role in DNA repair mechanisms\"}         ]     },     {         \"gene\": \"TP53\",         \"evidence\": [             {\"ref\": \"PMID:22222222\", \"text\": \"TP53 functions as a tumor suppressor\"},             {\"ref\": \"PMID:12345678\", \"text\": \"TP53 regulates cell cycle checkpoints\"},         ]     } ]  # Collect statistics stats = {     \"total\": 0,     \"passed\": 0,     \"failed\": 0,     \"by_gene\": defaultdict(lambda: {\"passed\": 0, \"failed\": 0}) }  for gene_data in gene_annotations:     gene = gene_data[\"gene\"]          for evidence in gene_data[\"evidence\"]:         result = validator.validate(             supporting_text=evidence[\"text\"],             reference_id=evidence[\"ref\"]         )                  stats[\"total\"] += 1         if result.is_valid:             stats[\"passed\"] += 1             stats[\"by_gene\"][gene][\"passed\"] += 1         else:             stats[\"failed\"] += 1             stats[\"by_gene\"][gene][\"failed\"] += 1  # Print summary print(\"Validation Statistics:\") print(f\"  Total validations: {stats['total']}\") print(f\"  Passed: {stats['passed']} ({stats['passed']/stats['total']*100:.1f}%)\") print(f\"  Failed: {stats['failed']} ({stats['failed']/stats['total']*100:.1f}%)\") print(\"\\nBy Gene:\") for gene, counts in stats[\"by_gene\"].items():     total = counts[\"passed\"] + counts[\"failed\"]     print(f\"  {gene}: {counts['passed']}/{total} passed\") <pre>Validation Statistics:\n  Total validations: 3\n  Passed: 1 (33.3%)\n  Failed: 2 (66.7%)\n\nBy Gene:\n  BRCA1: 0/1 passed\n  TP53: 1/2 passed\n</pre> In\u00a0[12]: Copied! <pre>class GeneAnnotationValidator:\n    \"\"\"Example class for validating gene annotations.\"\"\"\n    \n    def __init__(self, cache_dir: str):\n        config = ReferenceValidationConfig(cache_dir=cache_dir)\n        self.validator = SupportingTextValidator(config)\n    \n    def validate_annotation(self, annotation: dict) -&gt; dict:\n        \"\"\"Validate a single gene annotation.\n        \n        Args:\n            annotation: Dict with 'gene', 'function', and 'evidence' keys\n            \n        Returns:\n            Dict with validation results\n        \"\"\"\n        gene = annotation[\"gene\"]\n        evidence_list = annotation[\"evidence\"]\n        \n        results = []\n        all_valid = True\n        \n        for evidence in evidence_list:\n            result = self.validator.validate(\n                supporting_text=evidence[\"text\"],\n                reference_id=evidence[\"ref\"]\n            )\n            results.append({\n                \"reference\": evidence[\"ref\"],\n                \"text\": evidence[\"text\"],\n                \"valid\": result.is_valid,\n                \"message\": result.message\n            })\n            all_valid = all_valid and result.is_valid\n        \n        return {\n            \"gene\": gene,\n            \"valid\": all_valid,\n            \"evidence_results\": results\n        }\n\n# Use the validator\ngene_validator = GeneAnnotationValidator(cache_dir=str(cache_dir))\n\nannotation = {\n    \"gene\": \"TP53\",\n    \"function\": \"tumor suppressor\",\n    \"evidence\": [\n        {\"ref\": \"PMID:12345678\", \"text\": \"TP53 protein functions in cell cycle regulation\"},\n        {\"ref\": \"PMID:12345678\", \"text\": \"plays a critical role as a tumor suppressor\"},\n    ]\n}\n\nresult = gene_validator.validate_annotation(annotation)\n\nprint(f\"Gene: {result['gene']}\")\nprint(f\"Overall valid: {result['valid']}\")\nprint(\"\\nEvidence validation:\")\nfor ev_result in result['evidence_results']:\n    status = \"\u2713\" if ev_result['valid'] else \"\u2717\"\n    print(f\"  {status} {ev_result['reference']}: {ev_result['text'][:50]}...\")\n</pre> class GeneAnnotationValidator:     \"\"\"Example class for validating gene annotations.\"\"\"          def __init__(self, cache_dir: str):         config = ReferenceValidationConfig(cache_dir=cache_dir)         self.validator = SupportingTextValidator(config)          def validate_annotation(self, annotation: dict) -&gt; dict:         \"\"\"Validate a single gene annotation.                  Args:             annotation: Dict with 'gene', 'function', and 'evidence' keys                      Returns:             Dict with validation results         \"\"\"         gene = annotation[\"gene\"]         evidence_list = annotation[\"evidence\"]                  results = []         all_valid = True                  for evidence in evidence_list:             result = self.validator.validate(                 supporting_text=evidence[\"text\"],                 reference_id=evidence[\"ref\"]             )             results.append({                 \"reference\": evidence[\"ref\"],                 \"text\": evidence[\"text\"],                 \"valid\": result.is_valid,                 \"message\": result.message             })             all_valid = all_valid and result.is_valid                  return {             \"gene\": gene,             \"valid\": all_valid,             \"evidence_results\": results         }  # Use the validator gene_validator = GeneAnnotationValidator(cache_dir=str(cache_dir))  annotation = {     \"gene\": \"TP53\",     \"function\": \"tumor suppressor\",     \"evidence\": [         {\"ref\": \"PMID:12345678\", \"text\": \"TP53 protein functions in cell cycle regulation\"},         {\"ref\": \"PMID:12345678\", \"text\": \"plays a critical role as a tumor suppressor\"},     ] }  result = gene_validator.validate_annotation(annotation)  print(f\"Gene: {result['gene']}\") print(f\"Overall valid: {result['valid']}\") print(\"\\nEvidence validation:\") for ev_result in result['evidence_results']:     status = \"\u2713\" if ev_result['valid'] else \"\u2717\"     print(f\"  {status} {ev_result['reference']}: {ev_result['text'][:50]}...\") <pre>Gene: TP53\nOverall valid: True\n\nEvidence validation:\n  \u2713 PMID:12345678: TP53 protein functions in cell cycle regulation...\n  \u2713 PMID:12345678: plays a critical role as a tumor suppressor...\n</pre> In\u00a0[13]: Copied! <pre>import shutil\nshutil.rmtree(temp_dir)\nprint(f\"Cleaned up: {temp_dir}\")\n</pre> import shutil shutil.rmtree(temp_dir) print(f\"Cleaned up: {temp_dir}\") <pre>Cleaned up: /var/folders/nc/m4tx21912kv1b8nk3zzx9plr0000gn/T/tmpclsqvmjr\n</pre>"},{"location":"notebooks/03_python_api/#python-api-for-programmatic-usage","title":"Python API for Programmatic Usage\u00b6","text":"<p>This tutorial demonstrates using the Python API for integrating reference validation into your own applications.</p>"},{"location":"notebooks/03_python_api/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Review Tutorial 1 and Tutorial 2 for CLI usage patterns.</p>"},{"location":"notebooks/03_python_api/#when-to-use-the-python-api","title":"When to Use the Python API\u00b6","text":"<p>Use the Python API when you need to:</p> <ul> <li>Integrate validation into existing Python applications</li> <li>Build custom validation workflows</li> <li>Collect statistics and programmatic results</li> <li>Handle validation errors programmatically</li> </ul> <p>Note: For most use cases, the CLI is simpler and recommended.</p>"},{"location":"notebooks/03_python_api/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/03_python_api/#example-1-basic-validation","title":"Example 1: Basic Validation\u00b6","text":""},{"location":"notebooks/03_python_api/#example-2-working-with-validation-results","title":"Example 2: Working with Validation Results\u00b6","text":""},{"location":"notebooks/03_python_api/#example-3-batch-validation","title":"Example 3: Batch Validation\u00b6","text":""},{"location":"notebooks/03_python_api/#example-4-using-the-reference-fetcher","title":"Example 4: Using the Reference Fetcher\u00b6","text":""},{"location":"notebooks/03_python_api/#example-5-text-normalization","title":"Example 5: Text Normalization\u00b6","text":"<p>Understanding how text is normalized before matching.</p>"},{"location":"notebooks/03_python_api/#example-6-custom-configuration","title":"Example 6: Custom Configuration\u00b6","text":""},{"location":"notebooks/03_python_api/#example-7-error-handling","title":"Example 7: Error Handling\u00b6","text":""},{"location":"notebooks/03_python_api/#example-8-collecting-statistics","title":"Example 8: Collecting Statistics\u00b6","text":""},{"location":"notebooks/03_python_api/#example-9-integration-example","title":"Example 9: Integration Example\u00b6","text":"<p>A more complete example showing how to integrate into an application.</p>"},{"location":"notebooks/03_python_api/#summary","title":"Summary\u00b6","text":""},{"location":"notebooks/03_python_api/#key-classes","title":"Key Classes\u00b6","text":"<p><code>ReferenceValidationConfig</code> - Configuration</p> <pre>config = ReferenceValidationConfig(\n    cache_dir=\"path/to/cache\",\n    email=\"your@email.com\"\n)\n</pre> <p><code>SupportingTextValidator</code> - Main validator</p> <pre>validator = SupportingTextValidator(config)\nresult = validator.validate(\n    supporting_text=\"quote\",\n    reference_id=\"PMID:12345678\"\n)\n</pre> <p><code>ReferenceFetcher</code> - Fetch references</p> <pre>fetcher = ReferenceFetcher(config)\nreference = fetcher.fetch(\"PMID:12345678\")\n</pre>"},{"location":"notebooks/03_python_api/#when-to-use-python-api-vs-cli","title":"When to Use Python API vs CLI\u00b6","text":"<p>Use CLI when:</p> <ul> <li>Quick one-off validations</li> <li>Shell scripting</li> <li>CI/CD pipelines</li> <li>Standard LinkML workflows</li> </ul> <p>Use Python API when:</p> <ul> <li>Building custom applications</li> <li>Need programmatic access to results</li> <li>Custom validation workflows</li> <li>Collecting statistics/analytics</li> </ul>"},{"location":"notebooks/03_python_api/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>Review API Documentation</li> <li>Explore source code for advanced usage</li> <li>Check GitHub for examples</li> </ul>"},{"location":"notebooks/03_python_api/#cleanup","title":"Cleanup\u00b6","text":""},{"location":"notebooks/04_obo_validation/","title":"Validating OBO Format Files","text":"In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Create a sample OBO file with axiom annotations\ncat &gt; cellulosome_example.obo &lt;&lt; 'EOF'\nformat-version: 1.2\nidspace: ex https://example.org/\n\n[Term]\nid: GO:0043263\nname: cellulosome\nnamespace: cellular_component\nalt_id: GO:1990296\ndef: \"An extracellular multi-enzyme complex containing up to 11 different enzymes aligned on a non-catalytic scaffolding glycoprotein. Functions to hydrolyze cellulose.\" [PMID:11601609] {ex:supporting_text=\"a unique extracellular multi-enzyme complex, called cellulosome [containing] up to 11 different enzymes [which] are aligned on the non-catalytic scaffolding protein[PMID:11601609]\"}\nsynonym: \"scaffoldin complex\" NARROW []\nxref: Wikipedia:Cellulosome\nEOF\n\ncat cellulosome_example.obo\n</pre> %%bash # Create a sample OBO file with axiom annotations cat &gt; cellulosome_example.obo &lt;&lt; 'EOF' format-version: 1.2 idspace: ex https://example.org/  [Term] id: GO:0043263 name: cellulosome namespace: cellular_component alt_id: GO:1990296 def: \"An extracellular multi-enzyme complex containing up to 11 different enzymes aligned on a non-catalytic scaffolding glycoprotein. Functions to hydrolyze cellulose.\" [PMID:11601609] {ex:supporting_text=\"a unique extracellular multi-enzyme complex, called cellulosome [containing] up to 11 different enzymes [which] are aligned on the non-catalytic scaffolding protein[PMID:11601609]\"} synonym: \"scaffoldin complex\" NARROW [] xref: Wikipedia:Cellulosome EOF  cat cellulosome_example.obo In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Validate the OBO file\nlinkml-reference-validator validate text-file cellulosome_example.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --text-group 1 \\\n  --ref-group 2\n</pre> %%bash # Validate the OBO file linkml-reference-validator validate text-file cellulosome_example.obo \\   --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\   --text-group 1 \\   --ref-group 2 <p>What happened?</p> <ol> <li>The tool extracted the supporting text from the axiom annotation</li> <li>It fetched PMID:11601609 from PubMed (and cached it)</li> <li>It validated that the supporting text appears in the reference</li> <li>\u2705 Validation passed! The quote is authentic.</li> </ol> <p>Note that the supporting text includes editorial brackets <code>[containing]</code> and <code>[which]</code> - these are automatically ignored during matching.</p> In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Extract matches using grep to see what the regex captures\ngrep -oP 'ex:supporting_text=\"\\K[^\"]*(?=\")' cellulosome_example.obo | head -1\n</pre> %%bash # Extract matches using grep to see what the regex captures grep -oP 'ex:supporting_text=\"\\K[^\"]*(?=\")' cellulosome_example.obo | head -1 In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Create a larger OBO file with multiple terms\ncat &gt; multi_term_example.obo &lt;&lt; 'EOF'\nformat-version: 1.2\nidspace: ex https://example.org/\n\n[Term]\nid: GO:0043263\nname: cellulosome\ndef: \"An extracellular multi-enzyme complex containing up to 11 different enzymes aligned on a non-catalytic scaffolding glycoprotein.\" [PMID:11601609] {ex:supporting_text=\"a unique extracellular multi-enzyme complex, called cellulosome [containing] up to 11 different enzymes [which] are aligned on the non-catalytic scaffolding protein[PMID:11601609]\"}\nxref: Wikipedia:Cellulosome\n\n[Term]\nid: GO:0005737\nname: cytoplasm\ndef: \"The contents of a cell excluding the plasma membrane and nucleus, but including other subcellular structures.\" [PMID:9974395]\n\n[Term]\nid: GO:0016020\nname: membrane\ndef: \"A lipid bilayer along with all the proteins and protein complexes embedded in it and attached to it.\" [PMID:21258405] {ex:supporting_text=\"The membrane is composed of a lipid bilayer[PMID:21258405]\"}\nEOF\n</pre> %%bash # Create a larger OBO file with multiple terms cat &gt; multi_term_example.obo &lt;&lt; 'EOF' format-version: 1.2 idspace: ex https://example.org/  [Term] id: GO:0043263 name: cellulosome def: \"An extracellular multi-enzyme complex containing up to 11 different enzymes aligned on a non-catalytic scaffolding glycoprotein.\" [PMID:11601609] {ex:supporting_text=\"a unique extracellular multi-enzyme complex, called cellulosome [containing] up to 11 different enzymes [which] are aligned on the non-catalytic scaffolding protein[PMID:11601609]\"} xref: Wikipedia:Cellulosome  [Term] id: GO:0005737 name: cytoplasm def: \"The contents of a cell excluding the plasma membrane and nucleus, but including other subcellular structures.\" [PMID:9974395]  [Term] id: GO:0016020 name: membrane def: \"A lipid bilayer along with all the proteins and protein complexes embedded in it and attached to it.\" [PMID:21258405] {ex:supporting_text=\"The membrane is composed of a lipid bilayer[PMID:21258405]\"} EOF <p>Created <code>multi_term_example.obo</code> with 3 terms:</p> <ul> <li>GO:0043263 (cellulosome): has supporting text annotation</li> <li>GO:0005737 (cytoplasm): no supporting text annotation</li> <li>GO:0016020 (membrane): has supporting text annotation</li> </ul> In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Validate the file with multiple terms\nlinkml-reference-validator validate text-file multi_term_example.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --text-group 1 \\\n  --ref-group 2\n</pre> %%bash # Validate the file with multiple terms linkml-reference-validator validate text-file multi_term_example.obo \\   --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\   --text-group 1 \\   --ref-group 2 <p>Key observations:</p> <ul> <li>Only lines with <code>ex:supporting_text</code> annotations are validated</li> <li>Lines without the annotation are silently skipped (GO:0005737)</li> <li>Each match shows the line number for easy reference</li> <li>Both validations are reported in the summary</li> </ul> In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Summary mode - only shows statistics\nlinkml-reference-validator validate text-file multi_term_example.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --summary\n</pre> %%bash # Summary mode - only shows statistics linkml-reference-validator validate text-file multi_term_example.obo \\   --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\   --summary In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Verbose mode - shows detailed matching\nlinkml-reference-validator validate text-file cellulosome_example.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --verbose\n</pre> %%bash # Verbose mode - shows detailed matching linkml-reference-validator validate text-file cellulosome_example.obo \\   --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\   --verbose <p>%%bash</p> In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Use a custom cache directory\nmkdir -p obo_references_cache\n\nlinkml-reference-validator validate text-file cellulosome_example.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --cache-dir obo_references_cache\n\necho \"\"\necho \"Cache contents:\"\nls -lh obo_references_cache/\n</pre> %%bash # Use a custom cache directory mkdir -p obo_references_cache  linkml-reference-validator validate text-file cellulosome_example.obo \\   --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\   --cache-dir obo_references_cache  echo \"\" echo \"Cache contents:\" ls -lh obo_references_cache/ <p>%%bash</p> In\u00a0[\u00a0]: Copied! <pre>%%bash\n# View the cached reference\ncache_path=$(linkml-reference-validator cache lookup PMID:11601609)\necho \"Cached reference metadata:\"\nhead -20 \"$cache_path\"\necho \"\"\necho \"...\"\necho \"\"\necho \"Abstract excerpt:\"\ntail -10 \"$cache_path\"\n</pre> %%bash # View the cached reference cache_path=$(linkml-reference-validator cache lookup PMID:11601609) echo \"Cached reference metadata:\" head -20 \"$cache_path\" echo \"\" echo \"...\" echo \"\" echo \"Abstract excerpt:\" tail -10 \"$cache_path\" <p>%%bash</p> In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Create OBO with different annotation property\ncat &gt; custom_annotation.obo &lt;&lt; 'EOF'\nformat-version: 1.2\n\n[Term]\nid: GO:0043263\nname: cellulosome\ndef: \"An extracellular multi-enzyme complex.\" [PMID:11601609]\nproperty_value: evidence_text \"cellulosome is a multi-enzyme complex\" PMID:11601609\nEOF\n\necho \"\u2705 Created custom_annotation.obo\"\ncat custom_annotation.obo\n</pre> %%bash # Create OBO with different annotation property cat &gt; custom_annotation.obo &lt;&lt; 'EOF' format-version: 1.2  [Term] id: GO:0043263 name: cellulosome def: \"An extracellular multi-enzyme complex.\" [PMID:11601609] property_value: evidence_text \"cellulosome is a multi-enzyme complex\" PMID:11601609 EOF  echo \"\u2705 Created custom_annotation.obo\" cat custom_annotation.obo In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Validate with custom regex pattern\nlinkml-reference-validator validate text-file custom_annotation.obo \\\n  --regex 'evidence_text \"([^\"]+)\" (\\S+:\\S+)' \\\n  --text-group 1 \\\n  --ref-group 2\n</pre> %%bash # Validate with custom regex pattern linkml-reference-validator validate text-file custom_annotation.obo \\   --regex 'evidence_text \"([^\"]+)\" (\\S+:\\S+)' \\   --text-group 1 \\   --ref-group 2 In\u00a0[\u00a0]: Copied! <pre>%%bash\n# This should fail validation\nlinkml-reference-validator validate text-file invalid_example.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  || true\n</pre> %%bash # This should fail validation linkml-reference-validator validate text-file invalid_example.obo \\   --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\   || true <p>Expected result: Validation should fail and report that the text doesn't match the reference.</p> In\u00a0[\u00a0]: Copied! <pre>%%bash\n# 1. Agent adds new terms with supporting text to OBO file\ncat &gt; agent_additions.obo &lt;&lt; 'EOF'\nformat-version: 1.2\nidspace: ex https://example.org/\n\n[Term]\nid: GO:0043263\nname: cellulosome\ndef: \"An extracellular multi-enzyme complex containing up to 11 different enzymes aligned on a non-catalytic scaffolding glycoprotein.\" [PMID:11601609] {ex:supporting_text=\"a unique extracellular multi-enzyme complex, called cellulosome [containing] up to 11 different enzymes [which] are aligned on the non-catalytic scaffolding protein[PMID:11601609]\"}\nEOF\n\n# 2. Validate before committing\nlinkml-reference-validator validate text-file agent_additions.obo \\\n     --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n     --summary\n</pre> %%bash # 1. Agent adds new terms with supporting text to OBO file cat &gt; agent_additions.obo &lt;&lt; 'EOF' format-version: 1.2 idspace: ex https://example.org/  [Term] id: GO:0043263 name: cellulosome def: \"An extracellular multi-enzyme complex containing up to 11 different enzymes aligned on a non-catalytic scaffolding glycoprotein.\" [PMID:11601609] {ex:supporting_text=\"a unique extracellular multi-enzyme complex, called cellulosome [containing] up to 11 different enzymes [which] are aligned on the non-catalytic scaffolding protein[PMID:11601609]\"} EOF  # 2. Validate before committing linkml-reference-validator validate text-file agent_additions.obo \\      --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\      --summary <p>If validation passes, you can safely commit:</p> <pre>git add agent_additions.obo\ngit commit -m 'Add cellulosome with validated supporting text'\n</pre> <p>%%bash</p> <p>Usage: <code>./validate_obo.sh your_ontology.obo</code></p> In\u00a0[\u00a0]: Copied! <pre>%%bash\n# 1. Agent adds new terms with supporting text to OBO file\ncat &gt; agent_additions.obo &lt;&lt; 'EOF'\nformat-version: 1.2\nidspace: ex https://example.org/\n\n[Term]\nid: GO:0043263\nname: cellulosome\ndef: \"An extracellular multi-enzyme complex containing up to 11 different enzymes aligned on a non-catalytic scaffolding glycoprotein.\" [PMID:11601609] {ex:supporting_text=\"a unique extracellular multi-enzyme complex, called cellulosome [containing] up to 11 different enzymes [which] are aligned on the non-catalytic scaffolding protein[PMID:11601609]\"}\nEOF\n\n# 2. Validate before committing\necho \"Step 1: Validate agent additions...\"\nif linkml-reference-validator validate text-file agent_additions.obo \\\n     --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n     --summary; then\n  echo \"\"\n  echo \"\u2705 Step 2: All validations passed - safe to commit!\"\n  echo \"\u2705 Step 3: git add agent_additions.obo\"\n  echo \"\u2705 Step 4: git commit -m 'Add cellulosome with validated supporting text'\"\nelse\n  echo \"\"\n  echo \"\u274c Step 2: Validation failed - review before committing!\"\n  exit 1\nfi\n</pre> %%bash # 1. Agent adds new terms with supporting text to OBO file cat &gt; agent_additions.obo &lt;&lt; 'EOF' format-version: 1.2 idspace: ex https://example.org/  [Term] id: GO:0043263 name: cellulosome def: \"An extracellular multi-enzyme complex containing up to 11 different enzymes aligned on a non-catalytic scaffolding glycoprotein.\" [PMID:11601609] {ex:supporting_text=\"a unique extracellular multi-enzyme complex, called cellulosome [containing] up to 11 different enzymes [which] are aligned on the non-catalytic scaffolding protein[PMID:11601609]\"} EOF  # 2. Validate before committing echo \"Step 1: Validate agent additions...\" if linkml-reference-validator validate text-file agent_additions.obo \\      --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\      --summary; then   echo \"\"   echo \"\u2705 Step 2: All validations passed - safe to commit!\"   echo \"\u2705 Step 3: git add agent_additions.obo\"   echo \"\u2705 Step 4: git commit -m 'Add cellulosome with validated supporting text'\" else   echo \"\"   echo \"\u274c Step 2: Validation failed - review before committing!\"   exit 1 fi In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Example CI/CD script\ncat &gt; validate_obo.sh &lt;&lt; 'EOF'\n#!/bin/bash\nset -e  # Exit on any error\n\necho \"Validating OBO file supporting text...\"\n\nlinkml-reference-validator validate text-file \"$1\" \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --summary\n\nEXIT_CODE=$?\n\nif [ $EXIT_CODE -eq 0 ]; then\n  echo \"\u2705 All supporting text validated successfully\"\n  exit 0\nelse\n  echo \"\u274c Supporting text validation failed\"\n  echo \"Please review the errors above before merging.\"\n  exit 1\nfi\nEOF\n\nchmod +x validate_obo.sh\necho \"\u2705 Created validate_obo.sh script\"\necho \"\"\necho \"Usage: ./validate_obo.sh your_ontology.obo\"\n</pre> %%bash # Example CI/CD script cat &gt; validate_obo.sh &lt;&lt; 'EOF' #!/bin/bash set -e  # Exit on any error  echo \"Validating OBO file supporting text...\"  linkml-reference-validator validate text-file \"$1\" \\   --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\   --summary  EXIT_CODE=$?  if [ $EXIT_CODE -eq 0 ]; then   echo \"\u2705 All supporting text validated successfully\"   exit 0 else   echo \"\u274c Supporting text validation failed\"   echo \"Please review the errors above before merging.\"   exit 1 fi EOF  chmod +x validate_obo.sh echo \"\u2705 Created validate_obo.sh script\" echo \"\" echo \"Usage: ./validate_obo.sh your_ontology.obo\" In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Test the script\n./validate_obo.sh cellulosome_example.obo\n</pre> %%bash # Test the script ./validate_obo.sh cellulosome_example.obo <p>%%bash</p> In\u00a0[\u00a0]: Copied! <pre>%%bash\nlinkml-reference-validator validate text-file --help\n</pre> %%bash linkml-reference-validator validate text-file --help In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Clean up example files\nrm -f cellulosome_example.obo multi_term_example.obo custom_annotation.obo\nrm -f invalid_example.obo agent_additions.obo validate_obo.sh\nrm -rf obo_references_cache\necho \"\u2705 Cleaned up example files\"\n</pre> %%bash # Clean up example files rm -f cellulosome_example.obo multi_term_example.obo custom_annotation.obo rm -f invalid_example.obo agent_additions.obo validate_obo.sh rm -rf obo_references_cache echo \"\u2705 Cleaned up example files\""},{"location":"notebooks/04_obo_validation/#validating-obo-format-files","title":"Validating OBO Format Files\u00b6","text":"<p>This tutorial demonstrates how to validate supporting text in OBO format ontology files using the <code>validate text-file</code> command.</p>"},{"location":"notebooks/04_obo_validation/#background","title":"Background\u00b6","text":"<p>OBO format ontologies can include axiom annotations containing supporting text from publications. For example:</p> <pre><code>obo\n[Term]\nid: GO:0043263\nname: cellulosome\ndef: \"An extracellular multi-enzyme complex...\" [PMID:11601609] {\n  ex:supporting_text=\"a unique extracellular multi-enzyme complex, \n  called cellulosome[PMID:11601609]\"\n}\n</code></pre> <p>The <code>validate text-file</code> command extracts these annotations using regular expressions and validates them against the referenced publications.</p>"},{"location":"notebooks/04_obo_validation/#setup-create-a-sample-obo-file","title":"Setup: Create a Sample OBO File\u00b6","text":"<p>Let's create a sample OBO file with the cellulosome example from the GO database:</p>"},{"location":"notebooks/04_obo_validation/#part-1-basic-obo-validation","title":"Part 1: Basic OBO Validation\u00b6","text":"<p>The <code>validate text-file</code> command uses regex patterns to extract supporting text and reference IDs from text files.</p>"},{"location":"notebooks/04_obo_validation/#command-structure","title":"Command Structure\u00b6","text":"<pre>linkml-reference-validator validate text-file &lt;file&gt; \\\n  --regex &lt;pattern&gt; \\\n  --text-group &lt;number&gt; \\\n  --ref-group &lt;number&gt;\n</pre> <p>For OBO files with <code>ex:supporting_text</code> annotations, we use this regex:</p> <ul> <li>Pattern: <code>ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"</code></li> <li>Group 1 (text-group): Captures the supporting text</li> <li>Group 2 (ref-group): Captures the reference ID (e.g., PMID:11601609)</li> </ul>"},{"location":"notebooks/04_obo_validation/#part-2-understanding-the-regex-pattern","title":"Part 2: Understanding the Regex Pattern\u00b6","text":"<p>Let's break down the regex pattern:</p> <pre><code>regex\nex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"\n</code></pre> <ul> <li><code>ex:supporting_text=\"</code> - Literal match for the annotation property</li> <li><code>([^\"]*)</code> - Group 1: Captures everything before the final <code>[</code>, excluding quotes</li> <li><code>\\[</code> - Literal <code>[</code> character (escaped)</li> <li><code>(\\S+:\\S+)</code> - Group 2: Captures the reference ID (format: PREFIX:ID)</li> <li><code>\\]</code> - Literal <code>]</code> character (escaped)</li> <li><code>\"</code> - Closing quote</li> </ul> <p>Let's test pattern extraction without validation:</p>"},{"location":"notebooks/04_obo_validation/#part-3-multiple-terms-in-one-file","title":"Part 3: Multiple Terms in One File\u00b6","text":"<p>Let's add more terms to see batch validation:</p>"},{"location":"notebooks/04_obo_validation/#part-4-summary-mode","title":"Part 4: Summary Mode\u00b6","text":"<p>For large files, use <code>--summary</code> to see only the overall statistics:</p>"},{"location":"notebooks/04_obo_validation/#part-5-verbose-mode","title":"Part 5: Verbose Mode\u00b6","text":"<p>Use <code>--verbose</code> to see detailed matching information:</p>"},{"location":"notebooks/04_obo_validation/#use-a-custom-cache-directory","title":"Use a custom cache directory\u00b6","text":"<p>mkdir -p obo_references_cache</p> <p>linkml-reference-validator validate text-file cellulosome_example.obo  --regex 'ex:supporting_text=\"([^\"]*)[(\\S+:\\S+)]\"'  --cache-dir obo_references_cache</p> <p>ls -lh obo_references_cache/</p>"},{"location":"notebooks/04_obo_validation/#view-the-cached-reference","title":"View the cached reference\u00b6","text":"<p>head -20 references_cache/PMID_11601609.md echo \"\" echo \"...\" echo \"\" tail -10 references_cache/PMID_11601609.md</p>"},{"location":"notebooks/04_obo_validation/#create-obo-with-different-annotation-property","title":"Create OBO with different annotation property\u00b6","text":"<p>cat &gt; custom_annotation.obo &lt;&lt; 'EOF' format-version: 1.2</p> <p>[Term] id: GO:0043263 name: cellulosome def: \"An extracellular multi-enzyme complex.\" [PMID:11601609] property_value: evidence_text \"cellulosome is a multi-enzyme complex\" PMID:11601609 EOF</p> <p>cat custom_annotation.obo</p>"},{"location":"notebooks/04_obo_validation/#part-9-testing-with-invalid-text","title":"Part 9: Testing with Invalid Text\u00b6","text":"<p>Let's see what happens when supporting text doesn't match the reference:</p>"},{"location":"notebooks/04_obo_validation/#example-cicd-script","title":"Example CI/CD script\u00b6","text":"<p>cat &gt; validate_obo.sh &lt;&lt; 'EOF'</p>"},{"location":"notebooks/04_obo_validation/#binbash","title":"!/bin/bash\u00b6","text":"<p>set -e  # Exit on any error</p> <p>echo \"Validating OBO file supporting text...\"</p> <p>linkml-reference-validator validate text-file \"$1\"  --regex 'ex:supporting_text=\"([^\"]*)[(\\S+:\\S+)]\"'  --summary</p> <p>EXIT_CODE=$?</p> <p>if [ $EXIT_CODE -eq 0 ]; then echo \"\u2705 All supporting text validated successfully\" exit 0 else echo \"\u274c Supporting text validation failed\" echo \"Please review the errors above before merging.\" exit 1 fi EOF</p> <p>chmod +x validate_obo.sh</p>"},{"location":"notebooks/04_obo_validation/#part-11-integration-with-cicd","title":"Part 11: Integration with CI/CD\u00b6","text":"<p>You can use exit codes for automation:</p>"},{"location":"notebooks/04_obo_validation/#clean-up-example-files","title":"Clean up example files\u00b6","text":"<p>rm -f cellulosome_example.obo multi_term_example.obo custom_annotation.obo rm -f invalid_example.obo agent_additions.obo validate_obo.sh rm -rf obo_references_cache</p>"},{"location":"notebooks/04_obo_validation/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we learned:</p> <p>\u2705 Basic OBO validation - Extract and validate supporting text from axiom annotations \u2705 Regex patterns - Use custom patterns for different annotation formats \u2705 Batch processing - Validate multiple terms in one command \u2705 Summary mode - Quick statistics for large files \u2705 Verbose mode - Detailed matching information for debugging \u2705 Cache management - Organize downloaded references \u2705 Error detection - Identify hallucinated or incorrect supporting text \u2705 CI/CD integration - Automated validation in workflows</p>"},{"location":"notebooks/04_obo_validation/#key-command","title":"Key Command\u00b6","text":"<pre>linkml-reference-validator validate text-file ontology.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --text-group 1 \\\n  --ref-group 2\n</pre>"},{"location":"notebooks/04_obo_validation/#use-cases","title":"Use Cases\u00b6","text":"<ul> <li>AI-generated content - Validate agent-added definitions before committing</li> <li>Quality control - Batch validate existing annotations</li> <li>Pre-commit hooks - Prevent hallucinated text from entering the repository</li> <li>Curation workflows - Verify supporting evidence during manual curation</li> </ul>"},{"location":"notebooks/04_obo_validation/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>How-To Guide: Validating OBO Files</li> <li>Tutorial 1: Getting Started</li> <li>Tutorial 2: Advanced Usage</li> <li>Full Documentation</li> </ul>"},{"location":"notebooks/04_obo_validation/#cleanup-optional","title":"Cleanup (Optional)\u00b6","text":""},{"location":"notebooks/05_geo_validation/","title":"Validating GEO Dataset References","text":"In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Cache the GEO dataset\nlinkml-reference-validator cache reference GEO:GSE67472\n</pre> %%bash # Cache the GEO dataset linkml-reference-validator cache reference GEO:GSE67472 In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Validate text that should be in the dataset description\nlinkml-reference-validator validate text \\\n  \"Airway epithelial\" \\\n  GEO:GSE67472\n\necho \"Validation complete!\"\n</pre> %%bash # Validate text that should be in the dataset description linkml-reference-validator validate text \\   \"Airway epithelial\" \\   GEO:GSE67472  echo \"Validation complete!\" In\u00a0[\u00a0]: Copied! <pre>%%bash\n# This text is NOT in GSE67472\nlinkml-reference-validator validate text \\\n  \"This is completely unrelated to the dataset\" \\\n  GEO:GSE67472 \\\n  || echo \"Validation failed - text not found!\"\n</pre> %%bash # This text is NOT in GSE67472 linkml-reference-validator validate text \\   \"This is completely unrelated to the dataset\" \\   GEO:GSE67472 \\   || echo \"Validation failed - text not found!\" In\u00a0[\u00a0]: Copied! <pre>from linkml_reference_validator.models import ReferenceValidationConfig\nfrom linkml_reference_validator.etl.sources.entrez import GEOSource\n\n# Create config\nconfig = ReferenceValidationConfig(\n    email=\"your-email@example.com\",  # Required by NCBI\n    rate_limit_delay=0.5,  # Be respectful to the API\n)\n\n# Create the GEO source\nsource = GEOSource()\n\n# Fetch the dataset\nresult = source.fetch(\"GSE67472\", config)\n\nif result:\n    print(f\"Reference ID: {result.reference_id}\")\n    print(f\"Title: {result.title}\")\n    print(f\"Content type: {result.content_type}\")\n    print(f\"Entrez UID: {result.metadata.get('entrez_uid')}\")\n    print(f\"\\nContent preview:\\n{result.content[:500]}...\")\nelse:\n    print(\"Failed to fetch dataset\")\n</pre> from linkml_reference_validator.models import ReferenceValidationConfig from linkml_reference_validator.etl.sources.entrez import GEOSource  # Create config config = ReferenceValidationConfig(     email=\"your-email@example.com\",  # Required by NCBI     rate_limit_delay=0.5,  # Be respectful to the API )  # Create the GEO source source = GEOSource()  # Fetch the dataset result = source.fetch(\"GSE67472\", config)  if result:     print(f\"Reference ID: {result.reference_id}\")     print(f\"Title: {result.title}\")     print(f\"Content type: {result.content_type}\")     print(f\"Entrez UID: {result.metadata.get('entrez_uid')}\")     print(f\"\\nContent preview:\\n{result.content[:500]}...\") else:     print(\"Failed to fetch dataset\") In\u00a0[\u00a0]: Copied! <pre>from linkml_reference_validator.validation.supporting_text_validator import SupportingTextValidator\nfrom linkml_reference_validator.models import ReferenceValidationConfig\nfrom pathlib import Path\n\n# Create config with cache directory\nconfig = ReferenceValidationConfig(\n    cache_dir=Path(\"references_cache\"),\n    email=\"your-email@example.com\",\n    rate_limit_delay=0.5,\n)\n\n# Create validator\nvalidator = SupportingTextValidator(config)\n\n# Validate some text\nresult = validator.validate(\n    \"airway epithelial\",  # Text to validate\n    \"GEO:GSE67472\",  # Reference\n)\n\nprint(f\"Valid: {result.is_valid}\")\nprint(f\"Severity: {result.severity}\")\nprint(f\"Message: {result.message}\")\nif result.match_result:\n    print(f\"Found: {result.match_result.found}\")\n    print(f\"Matched text: {result.match_result.matched_text}\")\n</pre> from linkml_reference_validator.validation.supporting_text_validator import SupportingTextValidator from linkml_reference_validator.models import ReferenceValidationConfig from pathlib import Path  # Create config with cache directory config = ReferenceValidationConfig(     cache_dir=Path(\"references_cache\"),     email=\"your-email@example.com\",     rate_limit_delay=0.5, )  # Create validator validator = SupportingTextValidator(config)  # Validate some text result = validator.validate(     \"airway epithelial\",  # Text to validate     \"GEO:GSE67472\",  # Reference )  print(f\"Valid: {result.is_valid}\") print(f\"Severity: {result.severity}\") print(f\"Message: {result.message}\") if result.match_result:     print(f\"Found: {result.match_result.found}\")     print(f\"Matched text: {result.match_result.matched_text}\") In\u00a0[\u00a0]: Copied! <pre>from Bio import Entrez\n\nEntrez.email = \"your-email@example.com\"\n\n# Step 1: Convert accession to UID via esearch\nhandle = Entrez.esearch(db=\"gds\", term=\"GSE67472[Accession]\")\nsearch_result = Entrez.read(handle)\nhandle.close()\n\nprint(\"Accession: GSE67472\")\nprint(f\"UID(s) found: {search_result['IdList']}\")\n\nif search_result['IdList']:\n    uid = search_result['IdList'][0]\n    \n    # Step 2: Fetch summary using UID\n    handle = Entrez.esummary(db=\"gds\", id=uid)\n    summary = Entrez.read(handle)\n    handle.close()\n    \n    if summary:\n        record = summary[0]\n        print(f\"\\nDataset Title: {record.get('title')}\")\n        print(f\"Platform: {record.get('GPL')}\")\n        print(f\"Samples: {record.get('n_samples')}\")\n</pre> from Bio import Entrez  Entrez.email = \"your-email@example.com\"  # Step 1: Convert accession to UID via esearch handle = Entrez.esearch(db=\"gds\", term=\"GSE67472[Accession]\") search_result = Entrez.read(handle) handle.close()  print(\"Accession: GSE67472\") print(f\"UID(s) found: {search_result['IdList']}\")  if search_result['IdList']:     uid = search_result['IdList'][0]          # Step 2: Fetch summary using UID     handle = Entrez.esummary(db=\"gds\", id=uid)     summary = Entrez.read(handle)     handle.close()          if summary:         record = summary[0]         print(f\"\\nDataset Title: {record.get('title')}\")         print(f\"Platform: {record.get('GPL')}\")         print(f\"Samples: {record.get('n_samples')}\") In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Fetch a GSE series\nlinkml-reference-validator cache reference GEO:GSE67472\n</pre> %%bash # Fetch a GSE series linkml-reference-validator cache reference GEO:GSE67472 In\u00a0[\u00a0]: Copied! <pre>%%bash\n# Fetch a GDS dataset\nlinkml-reference-validator cache reference GEO:GDS1234\n</pre> %%bash # Fetch a GDS dataset linkml-reference-validator cache reference GEO:GDS1234 In\u00a0[\u00a0]: Copied! <pre>%%bash\n# List GEO references in cache\nls -lh references_cache/GEO_* 2&gt;/dev/null || echo \"No GEO references cached yet\"\n</pre> %%bash # List GEO references in cache ls -lh references_cache/GEO_* 2&gt;/dev/null || echo \"No GEO references cached yet\" In\u00a0[\u00a0]: Copied! <pre>%%bash\n# View a cached GEO reference (if it exists)\ncache_path=$(linkml-reference-validator cache lookup GEO:GSE67472 2&gt;/dev/null || true)\nif [ -n \"$cache_path\" ] &amp;&amp; [ -f \"$cache_path\" ]; then\n    head -30 \"$cache_path\"\nelse\n    echo \"GEO:GSE67472 not found in cache\"\nfi\n</pre> %%bash # View a cached GEO reference (if it exists) cache_path=$(linkml-reference-validator cache lookup GEO:GSE67472 2&gt;/dev/null || true) if [ -n \"$cache_path\" ] &amp;&amp; [ -f \"$cache_path\" ]; then     head -30 \"$cache_path\" else     echo \"GEO:GSE67472 not found in cache\" fi"},{"location":"notebooks/05_geo_validation/#validating-geo-dataset-references","title":"Validating GEO Dataset References\u00b6","text":"<p>This tutorial demonstrates how to validate supporting text quotes against Gene Expression Omnibus (GEO) datasets.</p>"},{"location":"notebooks/05_geo_validation/#what-is-geo","title":"What is GEO?\u00b6","text":"<p>GEO (Gene Expression Omnibus) is NCBI's public repository for gene expression and other functional genomics data. Each dataset has:</p> <ul> <li>GSE accessions: GEO Series (collections of related samples)</li> <li>GDS accessions: GEO DataSets (curated, analysis-ready datasets)</li> </ul> <p>The linkml-reference-validator can fetch and validate quotes against GEO dataset metadata.</p>"},{"location":"notebooks/05_geo_validation/#part-1-cli-validation","title":"Part 1: CLI Validation\u00b6","text":""},{"location":"notebooks/05_geo_validation/#fetching-a-geo-dataset","title":"Fetching a GEO Dataset\u00b6","text":"<p>Let's cache a real GEO dataset (GSE67472 - airway epithelial gene expression in asthma):</p>"},{"location":"notebooks/05_geo_validation/#validating-text-against-geo-dataset","title":"Validating Text Against GEO Dataset\u00b6","text":"<p>Now let's validate a quote from the dataset's description:</p>"},{"location":"notebooks/05_geo_validation/#validation-failure-example","title":"Validation Failure Example\u00b6","text":"<p>What happens when the text isn't in the dataset?</p>"},{"location":"notebooks/05_geo_validation/#part-2-python-api","title":"Part 2: Python API\u00b6","text":"<p>You can also use the Python API directly:</p>"},{"location":"notebooks/05_geo_validation/#validation-with-python-api","title":"Validation with Python API\u00b6","text":""},{"location":"notebooks/05_geo_validation/#part-3-how-geo-fetching-works","title":"Part 3: How GEO Fetching Works\u00b6","text":""},{"location":"notebooks/05_geo_validation/#the-accession-to-uid-conversion","title":"The Accession to UID Conversion\u00b6","text":"<p>GEO accessions (like GSE67472) cannot be used directly with NCBI's esummary API. The GEOSource automatically converts accessions to numeric UIDs:</p> <ol> <li>esearch: Searches for the accession and returns the numeric UID</li> <li>esummary: Uses the UID to fetch the dataset metadata</li> </ol> <p>You can see this in action:</p>"},{"location":"notebooks/05_geo_validation/#part-4-working-with-different-geo-types","title":"Part 4: Working with Different GEO Types\u00b6","text":""},{"location":"notebooks/05_geo_validation/#gse-geo-series","title":"GSE (GEO Series)\u00b6","text":"<p>GSE accessions represent collections of related samples:</p>"},{"location":"notebooks/05_geo_validation/#gds-geo-dataset","title":"GDS (GEO DataSet)\u00b6","text":"<p>GDS accessions are curated, analysis-ready datasets:</p>"},{"location":"notebooks/05_geo_validation/#part-5-viewing-cached-references","title":"Part 5: Viewing Cached References\u00b6","text":"<p>Cached GEO references are stored in markdown format:</p>"},{"location":"notebooks/05_geo_validation/#summary","title":"Summary\u00b6","text":"<p>In this tutorial, we learned:</p> <ol> <li>GEO accession types: GSE (Series) and GDS (DataSets)</li> <li>CLI usage: <code>cache reference GEO:GSExxxxx</code> and <code>validate text \"...\" GEO:GSExxxxx</code></li> <li>Python API: Using GEOSource and SupportingTextValidator</li> <li>How it works: Automatic accession-to-UID conversion via esearch</li> </ol>"},{"location":"notebooks/05_geo_validation/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>Validate quotes in your own data files with <code>validate data</code></li> <li>See Tutorial 3: Python API for more programmatic usage</li> <li>Check out Tutorial 4: OBO Validation for ontology validation</li> </ul>"},{"location":"reference/cli/","title":"CLI Reference","text":"<p>Complete command-line interface documentation.</p>"},{"location":"reference/cli/#main-command","title":"Main Command","text":"<pre><code>linkml-reference-validator [OPTIONS] COMMAND [ARGS]...\n</code></pre>"},{"location":"reference/cli/#options","title":"Options","text":"<ul> <li><code>--help</code> - Show help message and exit</li> </ul>"},{"location":"reference/cli/#commands","title":"Commands","text":"<ul> <li><code>lookup</code> - Look up reference metadata (quick lookups)</li> <li><code>validate</code> - Validate supporting text against references</li> <li><code>repair</code> - Repair supporting text validation errors</li> <li><code>cache</code> - Manage reference cache</li> </ul>"},{"location":"reference/cli/#lookup","title":"lookup","text":"<p>Look up reference metadata and content. Useful for quick \"what is this PMID?\" lookups.</p>"},{"location":"reference/cli/#usage","title":"Usage","text":"<pre><code>linkml-reference-validator lookup [OPTIONS] REFERENCE_ID [REFERENCE_ID...]\n</code></pre>"},{"location":"reference/cli/#arguments","title":"Arguments","text":"<ul> <li>REFERENCE_ID (required) - One or more reference IDs (e.g., PMID:12345678, DOI:10.1234/example)</li> </ul>"},{"location":"reference/cli/#options_1","title":"Options","text":"<ul> <li><code>--format, -f [md|json|yaml|text]</code> - Output format (default: md)</li> <li><code>--no-cache</code> - Bypass disk cache and fetch fresh from source</li> <li><code>--download-files, -D</code> - Download supplementary files from repositories (e.g., Zenodo)</li> <li><code>--cache-dir PATH, -c PATH</code> - Directory for caching references (default: <code>references_cache</code>)</li> <li><code>--config PATH</code> - Path to validation configuration file (.yaml)</li> <li><code>--verbose, -v</code> - Verbose output with detailed logging</li> <li><code>--help</code> - Show help message</li> </ul>"},{"location":"reference/cli/#examples","title":"Examples","text":"<p>Basic lookup:</p> <pre><code>linkml-reference-validator lookup PMID:16888623\n</code></pre> <p>Multiple references:</p> <pre><code>linkml-reference-validator lookup PMID:16888623 PMID:33505029\n</code></pre> <p>JSON output:</p> <pre><code>linkml-reference-validator lookup PMID:16888623 --format json\n</code></pre> <p>YAML output:</p> <pre><code>linkml-reference-validator lookup PMID:16888623 --format yaml\n</code></pre> <p>Text output (human-readable):</p> <pre><code>linkml-reference-validator lookup PMID:16888623 --format text\n</code></pre> <p>Force fresh fetch (bypass cache):</p> <pre><code>linkml-reference-validator lookup PMID:16888623 --no-cache\n</code></pre> <p>Zenodo DOI with supplementary files:</p> <pre><code>linkml-reference-validator lookup DOI:10.5281/zenodo.7961621\n</code></pre> <p>Download supplementary files:</p> <pre><code>linkml-reference-validator lookup -D DOI:10.5281/zenodo.7961621\n</code></pre>"},{"location":"reference/cli/#output-format","title":"Output Format","text":"<p>Markdown (default):</p> <pre><code>---\nreference_id: PMID:16888623\ntitle: MUC1 oncoprotein blocks nuclear targeting...\nauthors:\n- Raina D\n- Ahmad R\njournal: Cancer Research\nyear: '2006'\ndoi: 10.1158/0008-5472.CAN-06-0205\nkeywords:\n- Adaptor Proteins, Signal Transducing/metabolism\n- Cell Line, Tumor\ncontent_type: abstract_only\n---\n\n# MUC1 oncoprotein blocks nuclear targeting...\n**Authors:** Raina D, Ahmad R, ...\n**Journal:** Cancer Research (2006)\n**DOI:** [10.1158/...](https://doi.org/10.1158/...)\n\n## Content\n\n1. Cancer Res. 2006 Jul 1;66(13):6715-21...\n</code></pre> <p>Text format:</p> <pre><code>Reference: PMID:16888623\nTitle: MUC1 oncoprotein blocks nuclear targeting...\nAuthors: Raina D, Ahmad R, ...\nJournal: Cancer Research (2006)\nDOI: 10.1158/0008-5472.CAN-06-0205\nKeywords: Adaptor Proteins, Signal Transducing/metabolism, Cell Line, Tumor, ...\nContent type: abstract_only\n\n--- Content ---\n1. Cancer Res. 2006 Jul 1;66(13):6715-21...\n</code></pre> <p>With supplementary files (Zenodo):</p> <pre><code>Reference: DOI:10.5281/zenodo.7961621\nTitle: Gene Ontology Curators AI Workshop\nAuthors: Dickinson R, Carbon S, Mungall CJ\n...\nContent type: abstract_only\n\n--- Supplementary Files (3) ---\n  - Dickinson_Varenna2022.pdf (1,975,995 bytes)\n  - workshop_slides.pptx (2,345,678 bytes)\n  - data_analysis.xlsx (123,456 bytes)\n\n--- Content ---\n...\n</code></pre>"},{"location":"reference/cli/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code> - At least one reference fetched successfully</li> <li><code>1</code> - All references failed to fetch</li> </ul>"},{"location":"reference/cli/#validate","title":"validate","text":"<p>Validate supporting text against references.</p> <pre><code>linkml-reference-validator validate COMMAND [ARGS]...\n</code></pre>"},{"location":"reference/cli/#subcommands","title":"Subcommands","text":"<ul> <li><code>text</code> - Validate a single text quote</li> <li><code>text-file</code> - Validate supporting text extracted from a text file via regex</li> <li><code>data</code> - Validate supporting text in data files</li> </ul>"},{"location":"reference/cli/#validate-text","title":"validate text","text":"<p>Validate a single supporting text quote against a reference.</p>"},{"location":"reference/cli/#usage_1","title":"Usage","text":"<pre><code>linkml-reference-validator validate text [OPTIONS] TEXT REFERENCE_ID\n</code></pre>"},{"location":"reference/cli/#arguments_1","title":"Arguments","text":"<ul> <li>TEXT (required) - The supporting text to validate</li> <li>REFERENCE_ID (required) - Reference ID (e.g., PMID:12345678 or DOI:10.1234/example)</li> </ul>"},{"location":"reference/cli/#options_2","title":"Options","text":"<ul> <li><code>--title, -t TEXT</code> - Expected title to validate against the reference title</li> <li><code>--cache-dir PATH</code> - Directory for caching references (default: <code>references_cache</code>)</li> <li><code>--config PATH</code> - Path to validation configuration file (.yaml)</li> <li><code>--verbose, -v</code> - Verbose output with detailed logging</li> <li><code>--help</code> - Show help message</li> </ul>"},{"location":"reference/cli/#examples_1","title":"Examples","text":"<p>Basic validation:</p> <pre><code>linkml-reference-validator validate text \\\n  \"MUC1 oncoprotein blocks nuclear targeting\" \\\n  PMID:16888623\n</code></pre> <p>With custom cache directory:</p> <pre><code>linkml-reference-validator validate text \\\n  \"MUC1 oncoprotein blocks nuclear targeting\" \\\n  PMID:16888623 \\\n  --cache-dir /path/to/cache\n</code></pre> <p>With verbose output:</p> <pre><code>linkml-reference-validator validate text \\\n  \"MUC1 oncoprotein blocks nuclear targeting\" \\\n  PMID:16888623 \\\n  --verbose\n</code></pre> <p>With title check:</p> <pre><code>linkml-reference-validator validate text \\\n  \"Airway epithelial brushings\" \\\n  GEO:GSE67472 \\\n  --title \"Airway epithelial gene expression in asthma versus healthy controls\"\n</code></pre> <p>With editorial notes:</p> <pre><code>linkml-reference-validator validate text \\\n  'MUC1 [mucin 1] oncoprotein blocks nuclear targeting' \\\n  PMID:16888623\n</code></pre> <p>With ellipsis:</p> <pre><code>linkml-reference-validator validate text \\\n  \"MUC1 oncoprotein ... nuclear targeting\" \\\n  PMID:16888623\n</code></pre> <p>With DOI:</p> <pre><code>linkml-reference-validator validate text \\\n  \"Nanometre-scale thermometry\" \\\n  DOI:10.1038/nature12373\n</code></pre>"},{"location":"reference/cli/#exit-codes_1","title":"Exit Codes","text":"<ul> <li><code>0</code> - Validation successful</li> <li><code>1</code> - Validation failed</li> </ul>"},{"location":"reference/cli/#output-format_1","title":"Output Format","text":"<pre><code>Validating text against PMID:16888623...\n  Text: MUC1 oncoprotein blocks nuclear targeting\n\nResult:\n  Valid: True\n  Message: Supporting text validated successfully in PMID:16888623\n  Matched text: MUC1 oncoprotein blocks nuclear targeting...\n</code></pre>"},{"location":"reference/cli/#validate-text-file","title":"validate text-file","text":"<p>Validate supporting text in a text file by extracting quotes and references with a regex.</p>"},{"location":"reference/cli/#usage_2","title":"Usage","text":"<pre><code>linkml-reference-validator validate text-file [OPTIONS] FILE_PATH\n</code></pre>"},{"location":"reference/cli/#arguments_2","title":"Arguments","text":"<ul> <li>FILE_PATH (required) - Path to a text file (e.g., OBO, plain text)</li> </ul>"},{"location":"reference/cli/#options_3","title":"Options","text":"<ul> <li><code>--regex, -r TEXT</code> (required) - Regular expression with capture groups for text and reference ID</li> <li><code>--text-group, -t INTEGER</code> - Capture group number for supporting text (default: 1)</li> <li><code>--ref-group, -R INTEGER</code> - Capture group number for reference ID (default: 2)</li> <li><code>--summary, -s</code> - Show only summary statistics (skip per-line output)</li> <li><code>--cache-dir PATH, -c PATH</code> - Directory for caching references (default: <code>references_cache</code>)</li> <li><code>--config PATH</code> - Path to validation configuration file (.yaml)</li> <li><code>--verbose, -v</code> - Verbose output with detailed logging</li> <li><code>--help</code> - Show help message</li> </ul>"},{"location":"reference/cli/#examples_2","title":"Examples","text":"<p>Validate OBO axiom annotations:</p> <pre><code>linkml-reference-validator validate text-file my_ontology.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --text-group 1 \\\n  --ref-group 2\n</code></pre> <p>Summary only:</p> <pre><code>linkml-reference-validator validate text-file my_ontology.obo \\\n  --regex 'ex:supporting_text=\"([^\"]*)\\[(\\S+:\\S+)\\]\"' \\\n  --summary\n</code></pre>"},{"location":"reference/cli/#exit-codes_2","title":"Exit Codes","text":"<ul> <li><code>0</code> - Validation successful</li> <li><code>1</code> - Validation failed</li> </ul>"},{"location":"reference/cli/#validate-data","title":"validate data","text":"<p>Validate supporting text in data files against their cited references.</p>"},{"location":"reference/cli/#usage_3","title":"Usage","text":"<pre><code>linkml-reference-validator validate data [OPTIONS] DATA_FILE\n</code></pre>"},{"location":"reference/cli/#arguments_3","title":"Arguments","text":"<ul> <li>DATA_FILE (required) - Path to data file (YAML/JSON)</li> </ul>"},{"location":"reference/cli/#options_4","title":"Options","text":"<ul> <li><code>--schema PATH, -s PATH</code> (required) - Path to LinkML schema file</li> <li><code>--target-class TEXT, -t TEXT</code> - Target class to validate (optional)</li> <li><code>--cache-dir PATH, -c PATH</code> - Directory for caching references (default: <code>references_cache</code>)</li> <li><code>--config PATH</code> - Path to validation configuration file (.yaml)</li> <li><code>--verbose, -v</code> - Verbose output with detailed logging</li> <li><code>--help</code> - Show help message</li> </ul>"},{"location":"reference/cli/#examples_3","title":"Examples","text":"<p>Basic validation:</p> <pre><code>linkml-reference-validator validate data \\\n  data.yaml \\\n  --schema schema.yaml\n</code></pre> <p>With target class:</p> <pre><code>linkml-reference-validator validate data \\\n  data.yaml \\\n  --schema schema.yaml \\\n  --target-class Statement\n</code></pre> <p>With custom cache:</p> <pre><code>linkml-reference-validator validate data \\\n  data.yaml \\\n  --schema schema.yaml \\\n  --cache-dir /path/to/cache\n</code></pre> <p>With verbose output:</p> <pre><code>linkml-reference-validator validate data \\\n  data.yaml \\\n  --schema schema.yaml \\\n  --verbose\n</code></pre>"},{"location":"reference/cli/#exit-codes_3","title":"Exit Codes","text":"<ul> <li><code>0</code> - All validations passed</li> <li><code>1</code> - One or more validations failed</li> </ul>"},{"location":"reference/cli/#output-format_2","title":"Output Format","text":"<p>Success:</p> <pre><code>Validating data.yaml against schema schema.yaml\nCache directory: references_cache\n\nValidation Summary:\n  Total checks: 3\n  All validations passed!\n</code></pre> <p>Failure:</p> <pre><code>Validating data.yaml against schema schema.yaml\nCache directory: references_cache\n\nValidation Issues (2):\n  [ERROR] Text part not found as substring: 'MUC1 activates JAK-STAT'\n    Location: Statement\n\nValidation Summary:\n  Total checks: 3\n  Issues found: 2\n</code></pre>"},{"location":"reference/cli/#repair","title":"repair","text":"<p>Repair supporting text validation errors.</p> <pre><code>linkml-reference-validator repair COMMAND [ARGS]...\n</code></pre>"},{"location":"reference/cli/#subcommands_1","title":"Subcommands","text":"<ul> <li><code>text</code> - Repair a single text quote</li> <li><code>data</code> - Repair supporting text in data files</li> </ul>"},{"location":"reference/cli/#repair-text","title":"repair text","text":"<p>Attempt to repair a single supporting text quote.</p>"},{"location":"reference/cli/#usage_4","title":"Usage","text":"<pre><code>linkml-reference-validator repair text [OPTIONS] TEXT REFERENCE_ID\n</code></pre>"},{"location":"reference/cli/#arguments_4","title":"Arguments","text":"<ul> <li>TEXT (required) - The supporting text to repair</li> <li>REFERENCE_ID (required) - Reference ID (e.g., PMID:12345678 or DOI:10.1234/example)</li> </ul>"},{"location":"reference/cli/#options_5","title":"Options","text":"<ul> <li><code>--cache-dir PATH, -c PATH</code> - Directory for caching references</li> <li><code>--config PATH</code> - Path to configuration file (.yaml)</li> <li><code>--verbose, -v</code> - Verbose output with detailed logging</li> <li><code>--auto-fix-threshold FLOAT, -a FLOAT</code> - Minimum similarity for auto-fixes (default: 0.95)</li> <li><code>--help</code> - Show help message</li> </ul>"},{"location":"reference/cli/#examples_4","title":"Examples","text":"<p>Repair character normalization:</p> <pre><code>linkml-reference-validator repair text \\\n  \"CO2 levels were measured\" \\\n  PMID:12345678\n</code></pre> <p>With verbose output:</p> <pre><code>linkml-reference-validator repair text \\\n  \"protein functions in cells\" \\\n  PMID:12345678 \\\n  --verbose\n</code></pre>"},{"location":"reference/cli/#exit-codes_4","title":"Exit Codes","text":"<ul> <li><code>0</code> - Repair successful or already valid</li> <li><code>1</code> - Could not repair</li> </ul>"},{"location":"reference/cli/#output-format_3","title":"Output Format","text":"<p>Successful repair:</p> <pre><code>Attempting repair for PMID:12345678...\n  Text: CO2 levels were measured\n\nResult:\n  \u2713 Repaired successfully\n    Original: CO2 levels were measured\n    Repaired: CO\u2082 levels were measured\n    Action: CHARACTER_NORMALIZATION (Character normalization fix)\n    Confidence: HIGH\n</code></pre> <p>Already valid:</p> <pre><code>Result:\n  \u2713 Text already valid - no repair needed\n</code></pre> <p>Could not repair:</p> <pre><code>Result:\n  \u2717 Could not repair: Flagged for removal - text not found in reference\n    Suggestion: REMOVAL\n    Confidence: VERY_LOW (12%)\n</code></pre>"},{"location":"reference/cli/#repair-data","title":"repair data","text":"<p>Repair supporting text in data files.</p>"},{"location":"reference/cli/#usage_5","title":"Usage","text":"<pre><code>linkml-reference-validator repair data [OPTIONS] DATA_FILE\n</code></pre>"},{"location":"reference/cli/#arguments_5","title":"Arguments","text":"<ul> <li>DATA_FILE (required) - Path to data file (YAML)</li> </ul>"},{"location":"reference/cli/#options_6","title":"Options","text":"<ul> <li><code>--schema PATH, -s PATH</code> (required) - Path to LinkML schema file</li> <li><code>--target-class TEXT, -t TEXT</code> - Target class to validate</li> <li><code>--dry-run / --no-dry-run, -n / -N</code> - Show changes without applying (default: dry-run)</li> <li><code>--auto-fix-threshold FLOAT, -a FLOAT</code> - Minimum similarity for auto-fixes (default: 0.95)</li> <li><code>--output PATH, -o PATH</code> - Output file path (default: overwrite with backup)</li> <li><code>--config PATH</code> - Path to configuration file (.yaml)</li> <li><code>--cache-dir PATH, -c PATH</code> - Directory for caching references</li> <li><code>--verbose, -v</code> - Verbose output with detailed logging</li> <li><code>--help</code> - Show help message</li> </ul>"},{"location":"reference/cli/#examples_5","title":"Examples","text":"<p>Dry run (default):</p> <pre><code>linkml-reference-validator repair data \\\n  disease.yaml \\\n  --schema schema.yaml \\\n  --dry-run\n</code></pre> <p>Apply repairs:</p> <pre><code>linkml-reference-validator repair data \\\n  disease.yaml \\\n  --schema schema.yaml \\\n  --no-dry-run\n</code></pre> <p>Output to new file:</p> <pre><code>linkml-reference-validator repair data \\\n  disease.yaml \\\n  --schema schema.yaml \\\n  --no-dry-run \\\n  --output repaired.yaml\n</code></pre> <p>With configuration file:</p> <pre><code>linkml-reference-validator repair data \\\n  disease.yaml \\\n  --schema schema.yaml \\\n  --config .linkml-reference-validator.yaml\n</code></pre> <p>Custom threshold:</p> <pre><code>linkml-reference-validator repair data \\\n  disease.yaml \\\n  --schema schema.yaml \\\n  --auto-fix-threshold 0.98 \\\n  --no-dry-run\n</code></pre>"},{"location":"reference/cli/#exit-codes_5","title":"Exit Codes","text":"<ul> <li><code>0</code> - Repair completed (may have suggestions)</li> <li><code>1</code> - Repair completed but has removals or unverifiable items</li> </ul>"},{"location":"reference/cli/#output-format_4","title":"Output Format","text":"<pre><code>[DRY RUN] Repairing disease.yaml\n  Schema: schema.yaml\n  Auto-fix threshold: 0.95\n  Cache directory: references_cache\n\nFound 5 evidence item(s) to process\n\n============================================================\nRepair Report\n============================================================\n\nHIGH CONFIDENCE FIXES (auto-applicable):\n  PMID:12345678 at evidence[0]:\n    Character normalization fix\n    'CO2 levels...' \u2192 'CO\u2082 levels...'\n\nSUGGESTED FIXES (review recommended):\n  PMID:23456789 at evidence[1]:\n    Inserted ellipsis between non-contiguous parts\n\nRECOMMENDED REMOVALS (low confidence):\n  PMID:34567890 at evidence[2]:\n    Similarity: 8%\n    Snippet: 'Fabricated text...'\n\n------------------------------------------------------------\nSummary:\n  Total items: 5\n  Already valid: 2\n  Auto-fixes: 1\n  Suggestions: 1\n  Removals: 1\n  Unverifiable: 0\n</code></pre>"},{"location":"reference/cli/#configuration-file","title":"Configuration File","text":"<p>Create <code>.linkml-reference-validator.yaml</code> for project-specific settings. Use the <code>validation</code> section for reference fetching behavior and <code>repair</code> for auto-fix settings.</p> <pre><code>validation:\n  reference_prefix_map:\n    geo: GEO\n    NCBIGeo: GEO\n\nrepair:\n  # Confidence thresholds\n  auto_fix_threshold: 0.95\n  suggest_threshold: 0.80\n  removal_threshold: 0.50\n\n  # Character mappings\n  character_mappings:\n    \"+/-\": \"\u00b1\"\n    \"CO2\": \"CO\u2082\"\n    \"H2O\": \"H\u2082O\"\n\n  # References to skip\n  skip_references:\n    - \"PMID:12345678\"\n\n  # References trusted despite low similarity\n  trusted_low_similarity:\n    - \"PMID:98765432\"\n</code></pre>"},{"location":"reference/cli/#cache","title":"cache","text":"<p>Manage reference cache.</p> <pre><code>linkml-reference-validator cache COMMAND [ARGS]...\n</code></pre>"},{"location":"reference/cli/#subcommands_2","title":"Subcommands","text":"<ul> <li><code>reference</code> - Cache a reference for offline use</li> <li><code>lookup</code> - Show the cache path for a reference (or print file contents)</li> </ul>"},{"location":"reference/cli/#cache-reference","title":"cache reference","text":"<p>Pre-fetch and cache a reference for offline use.</p>"},{"location":"reference/cli/#usage_6","title":"Usage","text":"<pre><code>linkml-reference-validator cache reference [OPTIONS] REFERENCE_ID\n</code></pre>"},{"location":"reference/cli/#arguments_6","title":"Arguments","text":"<ul> <li>REFERENCE_ID (required) - Reference ID (e.g., PMID:12345678 or DOI:10.1234/example)</li> </ul>"},{"location":"reference/cli/#options_7","title":"Options","text":"<ul> <li><code>--cache-dir PATH, -c PATH</code> - Directory for caching references (default: <code>references_cache</code>)</li> <li><code>--config PATH</code> - Path to validation configuration file (.yaml)</li> <li><code>--force, -f</code> - Force re-fetch even if cached</li> <li><code>--verbose, -v</code> - Verbose output with detailed logging</li> <li><code>--help</code> - Show help message</li> </ul>"},{"location":"reference/cli/#examples_6","title":"Examples","text":"<p>Cache a reference:</p> <pre><code>linkml-reference-validator cache reference PMID:16888623\n</code></pre> <p>Force refresh:</p> <pre><code>linkml-reference-validator cache reference \\\n  PMID:16888623 \\\n  --force\n</code></pre> <p>Custom cache directory:</p> <pre><code>linkml-reference-validator cache reference \\\n  PMID:16888623 \\\n  --cache-dir /path/to/cache\n</code></pre> <p>Cache a DOI:</p> <pre><code>linkml-reference-validator cache reference DOI:10.1038/nature12373\n</code></pre>"},{"location":"reference/cli/#output-format_5","title":"Output Format","text":"<pre><code>Fetching PMID:16888623...\nSuccessfully cached PMID:16888623\n  Title: MUC1 oncoprotein blocks nuclear targeting...\n  Authors: Raina D, Ahmad R, Joshi MD\n  Content type: abstract_only\n  Content length: 1523 characters\n</code></pre>"},{"location":"reference/cli/#cache-lookup","title":"cache lookup","text":"<p>Show the cached file path for a reference, or print the cached file contents.</p>"},{"location":"reference/cli/#usage_7","title":"Usage","text":"<pre><code>linkml-reference-validator cache lookup [OPTIONS] REFERENCE_ID\n</code></pre>"},{"location":"reference/cli/#arguments_7","title":"Arguments","text":"<ul> <li>REFERENCE_ID (required) - Reference ID (e.g., PMID:12345678)</li> </ul>"},{"location":"reference/cli/#options_8","title":"Options","text":"<ul> <li><code>--content</code> - Show file contents instead of just the path</li> <li><code>--no-cache</code> - Bypass disk cache and fetch fresh from source</li> <li><code>--cache-dir PATH, -c PATH</code> - Directory for caching references (default: <code>references_cache</code>)</li> <li><code>--config PATH</code> - Path to validation configuration file (.yaml)</li> <li><code>--verbose, -v</code> - Verbose output with detailed logging</li> <li><code>--help</code> - Show help message</li> </ul>"},{"location":"reference/cli/#examples_7","title":"Examples","text":"<p>Show cache path:</p> <pre><code>linkml-reference-validator cache lookup PMID:16888623\n</code></pre> <p>Print cached content:</p> <pre><code>linkml-reference-validator cache lookup PMID:16888623 --content\n</code></pre> <p>Refresh then show path:</p> <pre><code>linkml-reference-validator cache lookup PMID:16888623 --no-cache\n</code></pre>"},{"location":"reference/cli/#reference-id-formats","title":"Reference ID Formats","text":""},{"location":"reference/cli/#pubmed-pmid","title":"PubMed (PMID)","text":"<pre><code>PMID:12345678\nPMID:9876543\n</code></pre> <ul> <li>Numeric identifier only</li> <li>Fetches abstract and metadata from NCBI</li> </ul>"},{"location":"reference/cli/#pubmed-central-pmc","title":"PubMed Central (PMC)","text":"<pre><code>PMC:3458566\nPMC:7654321\n</code></pre> <ul> <li>Numeric identifier only</li> <li>Fetches full-text when available</li> </ul>"},{"location":"reference/cli/#doi-digital-object-identifier","title":"DOI (Digital Object Identifier)","text":"<pre><code>DOI:10.1038/nature12373\nDOI:10.1126/science.1234567\n</code></pre> <ul> <li>Standard DOI format (10.prefix/suffix)</li> <li>Fetches metadata from Crossref API</li> <li>Abstract availability depends on publisher</li> </ul>"},{"location":"reference/cli/#configuration-notes","title":"Configuration Notes","text":"<ul> <li>The CLI currently does not read environment variables for cache dir or NCBI API keys.</li> <li>Use <code>--cache-dir</code> or set <code>cache_dir</code> in <code>.linkml-reference-validator.yaml</code>.</li> <li>Set <code>email</code> in <code>.linkml-reference-validator.yaml</code> for NCBI requests.</li> </ul>"},{"location":"reference/cli/#shell-integration","title":"Shell Integration","text":""},{"location":"reference/cli/#exit-code-usage","title":"Exit Code Usage","text":"<pre><code>if linkml-reference-validator validate text \\\n    \"MUC1 oncoprotein blocks nuclear targeting\" \\\n    PMID:16888623 &gt; /dev/null 2&gt;&amp;1; then\n  echo \"\u2713 Valid\"\nelse\n  echo \"\u2717 Invalid\"\nfi\n</code></pre>"},{"location":"reference/cli/#batch-processing","title":"Batch Processing","text":"<pre><code>for pmid in PMID:111 PMID:222 PMID:333; do\n  echo \"Validating $pmid...\"\n  linkml-reference-validator validate text \\\n    \"some text\" \\\n    \"$pmid\"\ndone\n</code></pre>"},{"location":"reference/cli/#piping-output","title":"Piping Output","text":"<pre><code># Save output to file\nlinkml-reference-validator validate text \\\n  \"...\" PMID:12345678 \\\n  &gt; validation_result.txt\n\n# Grep for specific info\nlinkml-reference-validator validate data \\\n  data.yaml \\\n  --schema schema.yaml \\\n  | grep \"Valid:\"\n</code></pre>"},{"location":"reference/cli/#backward-compatibility","title":"Backward Compatibility","text":"<p>Old hyphenated commands still work but are deprecated:</p> <pre><code># Old (deprecated but working)\nlinkml-reference-validator validate-text \"...\" PMID:123\nlinkml-reference-validator validate-data data.yaml --schema schema.yaml\nlinkml-reference-validator cache-reference PMID:123\n\n# New (preferred)\nlinkml-reference-validator validate text \"...\" PMID:123\nlinkml-reference-validator validate data data.yaml --schema schema.yaml\nlinkml-reference-validator cache reference PMID:123\n</code></pre> <p>The old commands are hidden from <code>--help</code> but continue to function.</p>"},{"location":"reference/cli/#see-also","title":"See Also","text":"<ul> <li>Quickstart - Get started quickly</li> <li>Tutorial 1 - CLI examples</li> <li>Python API - Programmatic usage</li> </ul>"}]}